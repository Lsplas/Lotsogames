<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Minecraft Titan Web Edition</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Courier New', Courier, monospace; }
        
        /* UI OVERLAY */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            background: transparent; border: 2px solid white; border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 10;
        }
        #hud {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 5px; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 10px;
        }
        .slot {
            width: 50px; height: 50px; background: rgba(0,0,0,0.5); border: 2px solid gray;
            display: flex; justify-content: center; align-items: center; cursor: pointer;
        }
        .slot.active { border: 3px solid white; background: rgba(100,100,100,0.5); }
        .slot-color { width: 30px; height: 30px; }

        /* INVENTORY MENU */
        #inventory {
            display: none; position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%); width: 600px; height: 400px;
            background: rgba(20, 20, 20, 0.95); border: 4px solid #555;
            padding: 20px; grid-template-columns: repeat(8, 1fr); grid-gap: 10px;
            overflow-y: auto; border-radius: 5px; z-index: 20;
        }
        .inv-item {
            width: 60px; height: 60px; background: rgba(255,255,255,0.1);
            border: 1px solid #444; cursor: pointer; display: flex; 
            flex-direction: column; align-items: center; justify-content: center;
        }
        .inv-item:hover { background: rgba(255,255,255,0.3); }
        .inv-name { font-size: 10px; color: white; text-align: center; margin-top: 5px; }
        
        #instructions {
            position: absolute; top: 10px; left: 10px; color: white; 
            background: rgba(0,0,0,0.5); padding: 10px; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="crosshair"></div>
    <div id="instructions">
        <b>WASD</b> Move | <b>SPACE</b> Jump | <b>Click</b> Lock Mouse<br>
        <b>L-Click</b> Break | <b>R-Click</b> Place<br>
        <b>E</b> Inventory | <b>1-9</b> Select Hotbar
    </div>

    <div id="inventory"></div>

    <div id="hud">
        </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.150.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.150.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- GAME CONFIGURATION ---
        const BLOCK_SIZE = 5;
        const WORLD_SIZE = 20; // 20x20 Chunks
        
        // --- ASSET DATABASE ---
        const ITEMS = [
            { id: 1, name: "Grass", color: 0x559037, type: 'block' },
            { id: 2, name: "Dirt", color: 0x795548, type: 'block' },
            { id: 3, name: "Stone", color: 0x808080, type: 'block' },
            { id: 4, name: "Deepslate", color: 0x3a3a3e, type: 'block' },
            { id: 5, name: "Bedrock", color: 0x111111, type: 'block' },
            { id: 6, name: "Oak Log", color: 0x5d4037, type: 'block' },
            { id: 7, name: "Leaves", color: 0x2e7d32, type: 'block' },
            { id: 8, name: "Planks", color: 0xbd8e56, type: 'block' },
            { id: 9, name: "Glass", color: 0xadd8e6, opacity: 0.5, type: 'block' },
            { id: 10, name: "Diamond Ore", color: 0x00ffff, type: 'block' },
            { id: 11, name: "Gold Ore", color: 0xffd700, type: 'block' },
            { id: 12, name: "Iron Ore", color: 0xd8bfd8, type: 'block' },
            { id: 13, name: "Amethyst", color: 0x9966cc, type: 'block' },
            { id: 20, name: "TNT", color: 0xff0000, type: 'block' },
            { id: 50, name: "Diamond Sword", color: 0x00aaaa, type: 'tool' },
            { id: 90, name: "Zombie Egg", color: 0x2e7d32, type: 'egg' },
            { id: 91, name: "Pig Egg", color: 0xffc0cb, type: 'egg' }
        ];

        let selectedItem = ITEMS[0];

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 10, 80);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- CONTROLS ---
        const controls = new PointerLockControls(camera, document.body);
        const instructions = document.getElementById('instructions');

        document.addEventListener('click', () => {
            if (!invOpen) controls.lock();
        });

        controls.addEventListener('lock', () => { instructions.style.display = 'none'; });
        controls.addEventListener('unlock', () => { if(!invOpen) instructions.style.display = 'block'; });

        // --- WORLD GENERATION ---
        const geometryBox = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        const meshes = []; // For collision and raycasting
        const chunks = new Map(); // Store block existence

        function createBlock(x, y, z, config) {
            const material = new THREE.MeshStandardMaterial({ 
                color: config.color, 
                transparent: config.opacity ? true : false,
                opacity: config.opacity || 1
            });
            const cube = new THREE.Mesh(geometryBox, material);
            cube.position.set(x, y, z);
            cube.castShadow = true;
            cube.receiveShadow = true;
            cube.userData = { isBlock: true, id: config.id };
            
            scene.add(cube);
            meshes.push(cube);
            chunks.set(`${x},${y},${z}`, cube);
            return cube;
        }

        // Generate Terrain
        function generateWorld() {
            for (let x = -WORLD_SIZE/2; x < WORLD_SIZE/2; x++) {
                for (let z = -WORLD_SIZE/2; z < WORLD_SIZE/2; z++) {
                    const wx = x * BLOCK_SIZE;
                    const wz = z * BLOCK_SIZE;
                    
                    // Bedrock
                    createBlock(wx, -2 * BLOCK_SIZE, wz, ITEMS.find(i=>i.name==="Bedrock"));
                    
                    // Dirt/Grass
                    createBlock(wx, -1 * BLOCK_SIZE, wz, ITEMS.find(i=>i.name==="Dirt"));
                    createBlock(wx, 0, wz, ITEMS.find(i=>i.name==="Grass"));

                    // Random Trees
                    if (Math.random() < 0.05) {
                        createTree(wx, BLOCK_SIZE, wz);
                    }
                }
            }
        }

        function createTree(x, y, z) {
            const log = ITEMS.find(i => i.name === "Oak Log");
            const leaf = ITEMS.find(i => i.name === "Leaves");
            
            // Trunk
            for(let i=0; i<4; i++) createBlock(x, y + (i*BLOCK_SIZE), z, log);
            
            // Leaves
            const topY = y + (3*BLOCK_SIZE);
            for(let lx=-1; lx<=1; lx++){
                for(let lz=-1; lz<=1; lz++){
                    if(lx===0 && lz===0) continue;
                    createBlock(x + (lx*BLOCK_SIZE), topY, z + (lz*BLOCK_SIZE), leaf);
                }
            }
            createBlock(x, topY + BLOCK_SIZE, z, leaf);
        }

        generateWorld();

        // --- PLAYER PHYSICS ---
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const moveSpeed = 400.0;
        const jumpForce = 300.0;
        let canJump = false;
        
        // Raycaster for interaction
        const raycaster = new THREE.Raycaster();
        const center = new THREE.Vector2(0, 0); // Center of screen

        // --- MOBS ---
        const mobs = [];
        const mobGeo = new THREE.BoxGeometry(4, 10, 4);
        
        function spawnMob(x, y, z, color) {
            const mat = new THREE.MeshStandardMaterial({ color: color });
            const mob = new THREE.Mesh(mobGeo, mat);
            mob.position.set(x, y + 5, z);
            mob.userData = { isMob: true, health: 3 };
            scene.add(mob);
            meshes.push(mob);
            mobs.push(mob);
        }

        // --- INPUT HANDLING ---
        const keys = { w: false, a: false, s: false, d: false, space: false };
        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'KeyW': keys.w = true; break;
                case 'KeyA': keys.a = true; break;
                case 'KeyS': keys.s = true; break;
                case 'KeyD': keys.d = true; break;
                case 'Space': if(canJump) { velocity.y += jumpForce; canJump = false; } break;
                case 'KeyE': toggleInventory(); break;
            }
            // Hotbar selection
            if(e.key >= '1' && e.key <= '9') selectHotbar(parseInt(e.key)-1);
        });
        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': keys.w = false; break;
                case 'KeyA': keys.a = false; break;
                case 'KeyS': keys.s = false; break;
                case 'KeyD': keys.d = false; break;
            }
        });

        // Mouse Interaction
        document.addEventListener('mousedown', (e) => {
            if (!controls.isLocked) return;
            
            raycaster.setFromCamera(center, camera);
            const intersects = raycaster.intersectObjects(meshes);

            if (intersects.length > 0) {
                const hit = intersects[0];
                const obj = hit.object;
                
                if (hit.distance > 25) return; // Reach distance

                if (e.button === 0) { 
                    // Left Click: Break / Attack
                    if (obj.userData.isBlock) {
                        scene.remove(obj);
                        meshes.splice(meshes.indexOf(obj), 1);
                        chunks.delete(`${obj.position.x},${obj.position.y},${obj.position.z}`);
                    } else if (obj.userData.isMob) {
                         // Hit Mob
                         obj.userData.health--;
                         obj.material.color.setHex(0xff0000);
                         setTimeout(() => obj.material.color.setHex(selectedItem.color), 200);
                         if(obj.userData.health <= 0) {
                             scene.remove(obj);
                             meshes.splice(meshes.indexOf(obj), 1);
                         }
                    }
                } 
                else if (e.button === 2) {
                    // Right Click: Place / Spawn
                    if (selectedItem.type === 'block') {
                        const p = hit.point.add(hit.face.normal.multiplyScalar(BLOCK_SIZE/2));
                        // Snap to grid
                        const gx = Math.round(p.x / BLOCK_SIZE) * BLOCK_SIZE;
                        const gy = Math.round(p.y / BLOCK_SIZE) * BLOCK_SIZE;
                        const gz = Math.round(p.z / BLOCK_SIZE) * BLOCK_SIZE;
                        
                        // Check if player is standing there
                        const dist = new THREE.Vector3(gx, gy, gz).distanceTo(camera.position);
                        if (dist > 8) {
                            createBlock(gx, gy, gz, selectedItem);
                        }
                    } else if (selectedItem.type === 'egg') {
                        spawnMob(hit.point.x, hit.point.y, hit.point.z, selectedItem.color);
                    }
                }
            }
        });

        // --- GUI & INVENTORY SYSTEM ---
        let invOpen = false;
        const invDiv = document.getElementById('inventory');
        const hudDiv = document.getElementById('hud');
        let hotbarSlots = [];

        // Fill Inventory Grid
        ITEMS.forEach(item => {
            const el = document.createElement('div');
            el.className = 'inv-item';
            el.innerHTML = `<div class="slot-color" style="background: #${item.color.toString(16)}"></div><div class="inv-name">${item.name}</div>`;
            el.onclick = () => {
                hotbarSlots[0].item = item; // For simplicity, replace slot 1
                selectHotbar(0);
                toggleInventory();
            };
            invDiv.appendChild(el);
        });

        // Init Hotbar
        for(let i=0; i<9; i++) {
            const el = document.createElement('div');
            el.className = 'slot';
            if (i === 0) el.classList.add('active');
            el.innerHTML = `<div class="slot-color"></div>`;
            hudDiv.appendChild(el);
            hotbarSlots.push({ el: el, item: ITEMS[i % ITEMS.length] });
            updateSlotVisual(i);
        }

        function updateSlotVisual(idx) {
            const s = hotbarSlots[idx];
            s.el.querySelector('.slot-color').style.background = '#' + s.item.color.toString(16);
        }

        function selectHotbar(idx) {
            hotbarSlots.forEach(s => s.el.classList.remove('active'));
            hotbarSlots[idx].el.classList.add('active');
            selectedItem = hotbarSlots[idx].item;
        }

        function toggleInventory() {
            invOpen = !invOpen;
            if (invOpen) {
                controls.unlock();
                invDiv.style.display = 'grid';
            } else {
                controls.lock();
                invDiv.style.display = 'none';
            }
        }

        // --- GAME LOOP ---
        let prevTime = performance.now();
        
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            if (controls.isLocked) {
                // Physics (Simple Euler)
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 100.0 * delta; // Gravity

                direction.z = Number(keys.w) - Number(keys.s);
                direction.x = Number(keys.d) - Number(keys.a);
                direction.normalize();

                if (keys.w || keys.s) velocity.z -= direction.z * moveSpeed * delta;
                if (keys.a || keys.d) velocity.x -= direction.x * moveSpeed * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                
                controls.getObject().position.y += (velocity.y * delta);

                // Simple Floor Collision
                if (controls.getObject().position.y < BLOCK_SIZE * 1.5) {
                    velocity.y = 0;
                    controls.getObject().position.y = BLOCK_SIZE * 1.5;
                    canJump = true;
                }
            }

            // Simple Mob AI (Bobbing)
            mobs.forEach(mob => {
                mob.rotation.y += delta;
                mob.position.y += Math.sin(time * 0.005) * 0.05;
            });

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
