<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DOOR 100: HARDCORE</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; font-family: 'Courier New', monospace; user-select: none; }
        
        /* UI OVERLAY */
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        /* TOP HUD */
        #hud-top { padding: 20px; display: flex; justify-content: space-between; align-items: flex-start; text-shadow: 2px 2px 0 #000; }
        #objective { color: #00ffff; font-size: 24px; font-weight: bold; background: rgba(0,0,0,0.5); padding: 10px; border: 1px solid #00aaaa; }
        #posture-warning { color: red; font-weight: bold; font-size: 20px; display: none; background: black; padding: 5px; }

        /* CENTER HUD */
        #center { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; }
        #crosshair { width: 6px; height: 6px; background: white; border-radius: 50%; margin: 0 auto; box-shadow: 0 0 4px white; }
        #interact-text { margin-top: 20px; color: white; font-size: 20px; font-weight: bold; text-shadow: 0 0 5px black; opacity: 0; }

        /* POSTURE ICON */
        #posture-icon { position: absolute; bottom: 20px; right: 20px; font-size: 40px; text-shadow: 0 0 10px black; }

        /* SCREENS */
        #screen-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; background: #0a0a0a; color: white; }
        h1 { color: #ef4444; font-size: 60px; margin: 0; letter-spacing: 5px; }
        button { background: #ef4444; color: white; border: none; padding: 15px 30px; font-size: 20px; font-family: inherit; cursor: pointer; margin-top: 20px; font-weight: bold; }
        button:hover { background: #ff6666; }
        .tips { margin-top: 20px; text-align: left; color: #aaa; background: #1a1a1a; padding: 20px; border-radius: 8px; }
        b { color: white; }
    </style>
</head>
<body>

    <div id="screen-overlay">
        <h1>DOOR 100</h1>
        <div class="tips">
            <p>üëÅÔ∏è <b>THE FIGURE</b> patrols randomly.</p>
            <p>üîä <b>DO NOT RUN:</b> If you uncrouch while moving, he attacks.</p>
            <p>‚ö° <b>OBJECTIVE:</b> Collect 10 High-Voltage Fuses.</p>
            <p>‚å®Ô∏è <b>CONTROLS:</b> WASD to Move, <b>C</b> to Crouch, <b>E</b> to Interact.</p>
        </div>
        <button id="start-btn">ENTER ELECTRICAL ROOM</button>
    </div>

    <div id="ui">
        <div id="hud-top">
            <div id="objective">FUSES: 0 / 10</div>
            <div id="posture-warning">‚ö† HE HEARS YOU RUNNING! ‚ö†</div>
        </div>
        <div id="center">
            <div id="crosshair"></div>
            <div id="interact-text">[E] COLLECT</div>
        </div>
        <div id="posture-icon">üèÉ</div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- AUDIO ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            
            const now = audioCtx.currentTime;
            if(type === 'fuse') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(1500, now+0.1);
                gain.gain.setValueAtTime(0.3, now); gain.gain.linearRampToValueAtTime(0, now+0.3);
                osc.start(now); osc.stop(now+0.3);
            } else if (type === 'roar') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.linearRampToValueAtTime(800, now+0.5);
                gain.gain.setValueAtTime(0.5, now); gain.gain.linearRampToValueAtTime(0, now+1.0);
                osc.start(now); osc.stop(now+1.0);
            } else if (type === 'step') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(50, now);
                gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.01, now+0.1);
                osc.start(now); osc.stop(now+0.1);
            }
        }

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        scene.fog = new THREE.Fog(0x050505, 5, 30); // Distance fog for atmosphere

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
        const renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- LIGHTING ---
        const ambient = new THREE.AmbientLight(0xffffff, 0.4); // Enough light to see
        scene.add(ambient);
        
        // Main overhead light
        const mainLight = new THREE.PointLight(0xffaa55, 1, 40);
        mainLight.position.set(0, 8, 0);
        mainLight.castShadow = true;
        scene.add(mainLight);

        // --- LEVEL GENERATION ---
        const interactables = [];
        const shelves = [];

        function createRoom() {
            // Floor
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(40, 40), new THREE.MeshStandardMaterial({color: 0x222222, roughness: 0.8}));
            floor.rotation.x = -Math.PI/2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Walls
            const wallMat = new THREE.MeshStandardMaterial({color: 0x444444});
            const w1 = new THREE.Mesh(new THREE.BoxGeometry(40, 8, 1), wallMat); w1.position.set(0, 4, -20); scene.add(w1);
            const w2 = new THREE.Mesh(new THREE.BoxGeometry(40, 8, 1), wallMat); w2.position.set(0, 4, 20); scene.add(w2);
            const w3 = new THREE.Mesh(new THREE.BoxGeometry(1, 8, 40), wallMat); w3.position.set(-20, 4, 0); scene.add(w3);
            const w4 = new THREE.Mesh(new THREE.BoxGeometry(1, 8, 40), wallMat); w4.position.set(20, 4, 0); scene.add(w4);

            // Shelves (Obstacles)
            for(let i=0; i<12; i++) {
                const w = 2 + Math.random()*2;
                const h = 4;
                const d = 6 + Math.random()*4;
                const x = (Math.random()-0.5) * 30;
                const z = (Math.random()-0.5) * 30;
                
                // Keep center clear for gameplay
                if(Math.abs(x) < 5 && Math.abs(z) < 5) continue;

                const shelf = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({color: 0x3d3328}));
                shelf.position.set(x, h/2, z);
                shelf.castShadow = true;
                shelf.receiveShadow = true;
                scene.add(shelf);
                shelves.push(shelf); // Store for simple collision if needed
            }

            // Breaker Box
            const box = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 1), new THREE.MeshStandardMaterial({color: 0x222222}));
            box.position.set(0, 3, -19);
            box.userData = { type: 'box' };
            interactables.push(box);
            scene.add(box);

            // Fuses (The "Good Looking" ones)
            for(let i=0; i<10; i++) {
                const fuseGroup = new THREE.Group();
                
                // Glowy Core
                const core = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.15, 0.6, 4, 8), 
                    new THREE.MeshStandardMaterial({
                        color: 0x00ffff, 
                        emissive: 0x00ffff, 
                        emissiveIntensity: 2.0
                    })
                );
                
                // Metal caps
                const cap1 = new THREE.Mesh(new THREE.CylinderGeometry(0.16, 0.16, 0.2), new THREE.MeshStandardMaterial({color: 0x888888, metalness: 1}));
                cap1.position.y = 0.35;
                const cap2 = cap1.clone();
                cap2.position.y = -0.35;

                // Point Light for Glow
                const light = new THREE.PointLight(0x00ffff, 1, 5);
                
                fuseGroup.add(core, cap1, cap2, light);
                
                // Placement
                fuseGroup.position.set((Math.random()-0.5)*35, 1, (Math.random()-0.5)*35);
                fuseGroup.userData = { type: 'fuse' };
                interactables.push(fuseGroup);
                scene.add(fuseGroup);
            }
        }

        // --- FIGURE (VISUALS) ---
        const figureGroup = new THREE.Group();
        function createFigure() {
            // Material
            const skin = new THREE.MeshStandardMaterial({color: 0x880000, roughness: 0.3, metalness: 0.2});

            // Torso (Ribcage look)
            const spine = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 1.5), skin);
            spine.position.y = 1.8;
            figureGroup.add(spine);

            // Ribs
            for(let i=0; i<4; i++) {
                const rib = new THREE.Mesh(new THREE.TorusGeometry(0.4 - (i*0.05), 0.05, 8, 16), skin);
                rib.rotation.x = Math.PI/2;
                rib.position.y = 2.2 - (i*0.3);
                figureGroup.add(rib);
            }

            // Head
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.45, 16, 16), skin);
            head.position.y = 2.8;
            
            // Mouth (Teeth)
            const mouthGeo = new THREE.CylinderGeometry(0.46, 0.46, 0.2, 16, 1, true, 0, Math.PI);
            const mouthMat = new THREE.MeshBasicMaterial({color: 0x000000, side: THREE.DoubleSide});
            const mouth = new THREE.Mesh(mouthGeo, mouthMat);
            mouth.rotation.x = Math.PI/2; // Face forward
            mouth.rotation.z = Math.PI/2;
            mouth.position.set(0, 0, 0); // Relative to head
            head.add(mouth);

            // Teeth
            for(let i=0; i<10; i++) {
                const tooth = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.1, 0.05), new THREE.MeshBasicMaterial({color: 0xffffff}));
                tooth.position.set(0.35 * Math.cos(i), 0, 0.35 * Math.sin(i)); // Circular arrangement
                mouth.add(tooth);
            }
            figureGroup.add(head);

            // Arms (Long)
            const armGeo = new THREE.BoxGeometry(0.15, 2, 0.15);
            const armL = new THREE.Mesh(armGeo, skin);
            armL.position.set(-0.6, 1.8, 0.2);
            armL.rotation.z = 0.2;
            const armR = new THREE.Mesh(armGeo, skin);
            armR.position.set(0.6, 1.8, 0.2);
            armR.rotation.z = -0.2;
            figureGroup.add(armL, armR);

            scene.add(figureGroup);
            figureGroup.position.set(0,0,15);
        }

        // --- GAME STATE ---
        const state = {
            fuses: 0,
            dead: false,
            crouching: false,
            figureState: 'PATROL', // PATROL, CHASE
            figureTarget: new THREE.Vector3(0,0,0)
        };

        const keys = { w:0, a:0, s:0, d:0 };
        const controls = new PointerLockControls(camera, document.body);
        const player = new THREE.Group();
        player.add(camera);
        scene.add(player);
        player.position.set(0, 1.7, 18); // Start near door

        // --- FIGURE AI ---
        function updateFigure(dt) {
            if(state.dead) return;

            const speed = state.figureState === 'CHASE' ? 9.5 : 3.5;
            const pos = figureGroup.position;
            const pPos = player.position;
            const dist = pos.distanceTo(pPos);

            // 1. HEARING LOGIC (The "Uncrouch = Death" Mechanic)
            const playerMoving = (keys.w || keys.a || keys.s || keys.d);
            const makingNoise = playerMoving && !state.crouching;

            if (makingNoise) {
                state.figureState = 'CHASE';
                document.getElementById('posture-warning').style.display = 'block';
            } else {
                document.getElementById('posture-warning').style.display = 'none';
            }

            if (state.figureState === 'CHASE') {
                // Run directly to player
                state.figureTarget.copy(pPos);
                
                // If player hides (crouches and stops moving) far enough, maybe lose interest? 
                // Hardcore mode: He remembers where you were for a bit.
                if (!makingNoise && dist > 10) {
                    // Chance to go back to patrol if far away and quiet
                    if(Math.random() < 0.01) state.figureState = 'PATROL';
                }
            } else {
                // PATROL LOGIC (Random Waypoints)
                if (pos.distanceTo(state.figureTarget) < 1) {
                    // Pick new random spot
                    state.figureTarget.set(
                        (Math.random() - 0.5) * 35,
                        0,
                        (Math.random() - 0.5) * 35
                    );
                }
                
                // Proximity detection (Visual/Feel)
                if (dist < 3) state.figureState = 'CHASE';
            }

            // Move Figure
            const dir = new THREE.Vector3().subVectors(state.figureTarget, pos);
            dir.y = 0;
            dir.normalize();
            
            // Simple obstruction avoidance (very basic)
            pos.addScaledVector(dir, speed * dt);
            figureGroup.lookAt(state.figureTarget.x, 1.8, state.figureTarget.z);

            // Animations
            const time = Date.now() * 0.005;
            figureGroup.position.y = Math.abs(Math.sin(time * (state.figureState==='CHASE'?2:1))) * 0.2; // Bobbing
            
            // Kill
            if (dist < 1.2) {
                gameOver("FIGURE CAUGHT YOU!");
            }
        }

        function gameOver(msg) {
            state.dead = true;
            document.exitPointerLock();
            document.getElementById('screen-overlay').style.display = 'flex';
            document.querySelector('h1').innerText = "YOU DIED";
            document.querySelector('.tips').innerHTML = `<p style="color:red; font-size:20px">${msg}</p>`;
            document.getElementById('start-btn').innerText = "TRY AGAIN";
            playSound('roar');
        }

        // --- INPUTS ---
        document.addEventListener('keydown', e => {
            if(e.code === 'KeyW') keys.w=1;
            if(e.code === 'KeyA') keys.a=1;
            if(e.code === 'KeyS') keys.s=1;
            if(e.code === 'KeyD') keys.d=1;
            if(e.code === 'KeyC') {
                state.crouching = true;
                player.position.y = 0.8;
                document.getElementById('posture-icon').innerText = 'üßé';
            }
            if(e.code === 'KeyE') interact();
        });
        document.addEventListener('keyup', e => {
            if(e.code === 'KeyW') keys.w=0;
            if(e.code === 'KeyA') keys.a=0;
            if(e.code === 'KeyS') keys.s=0;
            if(e.code === 'KeyD') keys.d=0;
            if(e.code === 'KeyC') {
                state.crouching = false;
                player.position.y = 1.7;
                document.getElementById('posture-icon').innerText = 'üèÉ';
            }
        });

        document.getElementById('start-btn').onclick = () => {
            if(state.dead) location.reload();
            document.getElementById('screen-overlay').style.display = 'none';
            controls.lock();
            createRoom();
            createFigure();
        };

        const raycaster = new THREE.Raycaster();
        function interact() {
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const hits = raycaster.intersectObjects(interactables, true);
            if(hits.length > 0 && hits[0].distance < 3.5) {
                let obj = hits[0].object;
                while(!obj.userData.type && obj.parent) obj = obj.parent;
                
                if(obj.userData.type === 'fuse') {
                    playSound('fuse');
                    state.fuses++;
                    scene.remove(obj);
                    obj.position.y = -100; // Hide
                    document.getElementById('objective').innerText = `FUSES: ${state.fuses} / 10`;
                } else if (obj.userData.type === 'box') {
                    if(state.fuses >= 10) {
                        alert("ELEVATOR POWERED! YOU ESCAPED!");
                        location.reload();
                    } else {
                        // Visual feedback for locked
                        document.getElementById('objective').style.borderColor = 'red';
                        setTimeout(() => document.getElementById('objective').style.borderColor = '#00aaaa', 200);
                    }
                }
            }
        }

        // --- LOOP ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();

            // Player Movement
            if(controls.isLocked && !state.dead) {
                const speed = state.crouching ? 2.5 : 6.0;
                const dir = new THREE.Vector3();
                const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); fwd.y=0; fwd.normalize();
                const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion); right.y=0; right.normalize();
                
                if(keys.w) dir.add(fwd); if(keys.s) dir.sub(fwd);
                if(keys.a) dir.sub(right); if(keys.d) dir.add(right);
                
                if(dir.length() > 0) {
                    dir.normalize();
                    player.position.addScaledVector(dir, speed * dt);
                }
            }

            // Figure Logic
            if(figureGroup) updateFigure(dt);

            // Visuals: Rotate Fuses
            interactables.forEach(obj => {
                if(obj.userData.type === 'fuse') {
                    obj.rotation.y += dt;
                    obj.rotation.z = Math.sin(Date.now()*0.002) * 0.2;
                }
            });

            // UI Raycast
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const hits = raycaster.intersectObjects(interactables, true);
            const txt = document.getElementById('interact-text');
            if(hits.length > 0 && hits[0].distance < 3.5) {
                txt.style.opacity = 1;
                let t = hits[0].object.userData.type || hits[0].object.parent.userData.type;
                txt.innerText = t === 'fuse' ? "[E] GRAB FUSE" : (state.fuses===10?"[E] ACTIVATE":"[E] LOCKED");
            } else {
                txt.style.opacity = 0;
            }

            renderer.render(scene, camera);
        }
        animate();
        
        window.onresize = () => { camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); };

    </script>
</body>
</html>
