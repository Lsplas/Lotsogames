<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DOOR 100: EXPANDED</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; user-select: none; }
        
        /* UI LAYOUT */
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        /* HUD ELEMENTS */
        #hud-top { padding: 30px; display: flex; justify-content: space-between; align-items: flex-start; }
        
        #objective-panel {
            background: rgba(0, 0, 0, 0.7);
            border-left: 5px solid #00ffaa;
            padding: 15px 30px;
            color: white;
            box-shadow: 0 0 20px rgba(0, 255, 170, 0.2);
        }
        #obj-title { font-size: 14px; color: #aaa; letter-spacing: 2px; margin-bottom: 5px; text-transform: uppercase; }
        #obj-count { font-size: 36px; font-weight: bold; color: #00ffaa; text-shadow: 0 0 10px #00ffaa; }

        #noise-meter {
            background: rgba(0,0,0,0.7);
            border-right: 5px solid red;
            padding: 15px;
            text-align: right;
            opacity: 0; /* Hidden unless making noise */
            transition: opacity 0.2s;
        }
        .noise-text { color: red; font-size: 24px; font-weight: bold; text-transform: uppercase; animation: pulse 0.5s infinite; }

        /* CENTER INTERACT */
        #center { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: flex; flex-direction: column; align-items: center; }
        #crosshair { width: 6px; height: 6px; background: rgba(255,255,255,0.5); border-radius: 50%; border: 1px solid white; }
        #interact-msg { margin-top: 40px; background: black; color: white; padding: 10px 20px; border-radius: 5px; font-weight: bold; font-size: 18px; border: 1px solid #555; opacity: 0; transition: opacity 0.2s; }

        /* CONTROLS HINT */
        #controls { position: absolute; bottom: 30px; left: 30px; color: #888; font-size: 14px; }
        #posture { position: absolute; bottom: 30px; right: 30px; font-size: 60px; filter: drop-shadow(0 0 5px black); transition: transform 0.2s; }

        /* OVERLAYS */
        #screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #0a0a0a; z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; transition: opacity 1s; }
        h1 { font-size: 80px; color: #e67e22; text-shadow: 0 0 30px #e67e22; margin: 0; letter-spacing: -2px; }
        p { font-size: 20px; color: #ccc; max-width: 600px; text-align: center; margin-bottom: 40px; line-height: 1.6; }
        button { background: #e67e22; color: black; border: none; padding: 15px 50px; font-size: 24px; font-weight: bold; cursor: pointer; border-radius: 5px; transition: transform 0.2s; }
        button:hover { transform: scale(1.05); background: white; }

        #jumpscare { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: black; z-index: 200; display: none; align-items: center; justify-content: center; overflow: hidden; }
        #scare-face { width: 100%; height: 100%; object-fit: contain; animation: shake 0.05s infinite; }

        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }
        @keyframes shake { 0% { transform: translate(10px, 10px) rotate(2deg); } 50% { transform: translate(-10px, -10px) rotate(-2deg); } 100% { transform: translate(0,0); } }
    </style>
</head>
<body>

    <div id="screen">
        <h1>DOOR 100</h1>
        <p>You are trapped in the Grand Archive.</p>
        <p>1. Find <b>10 CIRCUIT BREAKERS</b>.<br>
           2. The Figure is <b>BLIND</b> but hears <b>RUNNING</b>.<br>
           3. <b>CROUCH (C)</b> to stay silent.</p>
        <button id="start-btn">ENTER ROOM</button>
    </div>

    <div id="jumpscare"></div>

    <div id="ui">
        <div id="hud-top">
            <div id="objective-panel">
                <div id="obj-title">Breakers Found</div>
                <div id="obj-count">0 / 10</div>
            </div>
            <div id="noise-meter">
                <div class="noise-text">LOUD NOISE!</div>
                <div style="color:white; font-size:12px;">He hears you...</div>
            </div>
        </div>

        <div id="center">
            <div id="crosshair"></div>
            <div id="interact-msg">[E] PICK UP</div>
        </div>

        <div id="controls">
            [W,A,S,D] Move &nbsp; [C] Crouch &nbsp; [E] Interact
        </div>
        <div id="posture">üèÉ</div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- 1. AUDIO SYSTEM ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if(type === 'collect') {
                osc.type = 'sine'; 
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now+0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now+0.2);
                osc.start(now); osc.stop(now+0.2);
            } else if(type === 'roar') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.linearRampToValueAtTime(50, now+1.0);
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.linearRampToValueAtTime(0, now+1.0);
                osc.start(now); osc.stop(now+1.0);
            } else if(type === 'scream') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(50, now+1.5);
                gain.gain.setValueAtTime(0.8, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now+1.5);
                osc.start(now); osc.stop(now+1.5);
            }
        }

        // --- 2. SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        scene.fog = new THREE.Fog(0x050505, 10, 60); // Dark atmosphere

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 200);
        const renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- 3. LEVEL GENERATION (COLORS & BIGGER MAP) ---
        const interactables = [];
        const obstacles = [];
        
        // Materials
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x3e2723, roughness: 0.9 }); // Dark Wood
        const wallMat = new THREE.MeshStandardMaterial({ color: 0x263238, roughness: 0.8 });  // Dark Blue/Grey Paint
        const shelfMat = new THREE.MeshStandardMaterial({ color: 0x1c1c1c, roughness: 0.5, metalness: 0.5 }); // Black Metal
        const woodMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });
        
        function createLevel() {
            // 1. FLOOR (100x100)
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), floorMat);
            floor.rotation.x = -Math.PI/2;
            floor.receiveShadow = true;
            scene.add(floor);

            // 2. CEILING
            const ceil = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshStandardMaterial({color:0x111111}));
            ceil.rotation.x = Math.PI/2;
            ceil.position.y = 12;
            scene.add(ceil);

            // 3. WALLS
            const addWall = (w, h, d, x, z) => {
                const wall = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), wallMat);
                wall.position.set(x, h/2, z);
                wall.castShadow = true; wall.receiveShadow = true;
                scene.add(wall);
                obstacles.push(wall);
            };
            addWall(100, 12, 1, 0, -50);
            addWall(100, 12, 1, 0, 50);
            addWall(1, 12, 100, -50, 0);
            addWall(1, 12, 100, 50, 0);

            // 4. SHELVES (The Maze)
            // Function to build a detailed shelf
            const buildShelf = (x, z, rot) => {
                const group = new THREE.Group();
                group.position.set(x, 0, z);
                group.rotation.y = rot;

                // Frame
                const frameGeo = new THREE.BoxGeometry(4, 8, 1.5);
                const frame = new THREE.Mesh(frameGeo, shelfMat);
                frame.position.y = 4;
                frame.castShadow = true; frame.receiveShadow = true;
                group.add(frame);
                
                // Add Books/Boxes for Color
                for(let i=0; i<8; i++) {
                    const boxColor = Math.random() > 0.5 ? 0x8d6e63 : (Math.random()>0.5 ? 0x2e7d32 : 0xc62828); // Brown, Green, or Red
                    const box = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.6, 0.8), new THREE.MeshStandardMaterial({color: boxColor}));
                    
                    // Random placement on shelf
                    const level = 1 + Math.floor(Math.random()*3) * 2; // heights 1, 3, 5, 7
                    box.position.set((Math.random()-0.5)*3, level, (Math.random()-0.5)*0.5);
                    group.add(box);
                }
                
                scene.add(group);
                obstacles.push(frame); // Add collision logic later based on world position
                // We add a simple invisible box for collision to the obstacles array
                const colBox = new THREE.Mesh(new THREE.BoxGeometry(4, 8, 1.5), new THREE.MeshBasicMaterial({visible:false}));
                colBox.position.set(x, 4, z);
                colBox.rotation.y = rot;
                obstacles.push(colBox);
            };

            // Grid Generation for Shelves
            for(let x = -40; x <= 40; x+=12) {
                for(let z = -40; z <= 40; z+=12) {
                    // Leave spawn area clear
                    if(Math.abs(x) < 10 && Math.abs(z) < 10) continue;
                    
                    // Random rotation
                    const rot = Math.random() > 0.5 ? Math.PI/2 : 0;
                    buildShelf(x, z, rot);
                }
            }

            // 5. LIGHTING
            const ambient = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambient);

            // Add warm ceiling lights
            for(let x = -30; x <= 30; x+=30) {
                for(let z = -30; z <= 30; z+=30) {
                    const light = new THREE.PointLight(0xffaa00, 0.8, 35);
                    light.position.set(x, 10, z);
                    light.castShadow = true;
                    scene.add(light);
                    
                    // Bulb mesh
                    const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({color: 0xffaa00}));
                    bulb.position.set(x, 11, z);
                    scene.add(bulb);
                }
            }

            // 6. OBJECTIVES (Breakers)
            for(let i=0; i<10; i++) {
                const g = new THREE.Group();
                const m = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 1), new THREE.MeshStandardMaterial({color:0x333}));
                const knob = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.5), new THREE.MeshBasicMaterial({color:0x00ffaa})); // Glowing Green
                knob.rotation.x = Math.PI/2;
                
                // Light emitter for the item
                const iLight = new THREE.PointLight(0x00ffaa, 1, 5);
                
                g.add(m, knob, iLight);
                
                // Random position
                g.position.set((Math.random()-0.5)*80, 1, (Math.random()-0.5)*80);
                g.userData = { type: 'breaker' };
                scene.add(g);
                interactables.push(g);
            }

            // EXIT DOOR BOX
            const exit = new THREE.Mesh(new THREE.BoxGeometry(4, 6, 1), new THREE.MeshStandardMaterial({color:0x444}));
            exit.position.set(0, 3, -49);
            exit.userData = { type: 'exit' };
            interactables.push(exit);
            scene.add(exit);
        }

        // --- 4. THE FIGURE (RED MONSTER) ---
        const figure = new THREE.Group();
        function createFigure() {
            const mat = new THREE.MeshStandardMaterial({color: 0x8b0000, roughness: 0.3}); // Deep Red
            
            // Torso
            const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.3, 1.5), mat);
            torso.position.y = 2.5;
            
            // Head
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.5), mat);
            head.position.y = 3.5;
            
            // Scary Mouth
            const mouth = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.1, 0.4, 8, 1, true), new THREE.MeshBasicMaterial({color:0x000000, side:THREE.DoubleSide}));
            mouth.rotation.x = Math.PI/2;
            mouth.position.set(0, 0, 0.35);
            head.add(mouth);

            // Legs
            const legGeo = new THREE.CylinderGeometry(0.15, 0.15, 1.8);
            const l1 = new THREE.Mesh(legGeo, mat); l1.position.set(-0.3, 0.9, 0);
            const l2 = new THREE.Mesh(legGeo, mat); l2.position.set(0.3, 0.9, 0);

            // Arms
            const armGeo = new THREE.CylinderGeometry(0.12, 0.12, 2.0);
            const a1 = new THREE.Mesh(armGeo, mat); a1.position.set(-0.6, 2.5, 0); a1.rotation.z = 0.2;
            const a2 = new THREE.Mesh(armGeo, mat); a2.position.set(0.6, 2.5, 0); a2.rotation.z = -0.2;

            figure.add(torso, head, l1, l2, a1, a2);
            figure.position.set(0, 0, 40); // Start far away
            scene.add(figure);
        }

        // --- 5. GAME LOGIC ---
        const controls = new PointerLockControls(camera, document.body);
        const player = new THREE.Group();
        player.add(camera);
        scene.add(player);
        player.position.set(0, 1.7, 45); // Start at back

        let state = {
            fuses: 0,
            dead: false,
            crouching: false,
            figState: 'PATROL',
            figTarget: new THREE.Vector3(),
            lastHeardTime: 0
        };
        const keys = { w:0, a:0, s:0, d:0 };

        document.getElementById('start-btn').onclick = () => {
            document.getElementById('screen').style.opacity = 0;
            setTimeout(() => document.getElementById('screen').style.display = 'none', 1000);
            createLevel();
            createFigure();
            controls.lock();
        };

        // Inputs
        document.addEventListener('keydown', e => {
            if(e.code==='KeyW') keys.w=1; if(e.code==='KeyS') keys.s=1;
            if(e.code==='KeyA') keys.a=1; if(e.code==='KeyD') keys.d=1;
            if(e.code==='KeyC') toggleCrouch();
            if(e.code==='KeyE') interact();
        });
        document.addEventListener('keyup', e => {
            if(e.code==='KeyW') keys.w=0; if(e.code==='KeyS') keys.s=0;
            if(e.code==='KeyA') keys.a=0; if(e.code==='KeyD') keys.d=0;
        });

        function toggleCrouch() {
            state.crouching = !state.crouching;
            player.position.y = state.crouching ? 0.9 : 1.7;
            document.getElementById('posture').innerText = state.crouching ? 'üßé' : 'üèÉ';
            document.getElementById('posture').style.transform = state.crouching ? "scale(0.8)" : "scale(1)";
        }

        // --- AI LOGIC ---
        function updateFigure(dt) {
            if(state.dead) return;

            const dist = figure.position.distanceTo(player.position);
            const isRunning = (keys.w||keys.a||keys.s||keys.d) && !state.crouching;
            const hearingRange = 60; // He hears you from far away if you run

            // HEARING
            if(isRunning && dist < hearingRange) {
                // He hears you!
                state.figState = 'CHASE';
                state.figTarget.copy(player.position); // Target your CURRENT sound location
                state.lastHeardTime = Date.now();
                document.getElementById('noise-meter').style.opacity = 1;
                
                // Roar occasionally
                if(Math.random() < 0.02) playSound('roar');
            } else {
                document.getElementById('noise-meter').style.opacity = 0;
                // If he reached the last heard spot and sees nothing, go back to patrol
                if(state.figState === 'CHASE' && figure.position.distanceTo(state.figTarget) < 2) {
                    if(Date.now() - state.lastHeardTime > 2000) {
                        state.figState = 'PATROL';
                    }
                }
            }

            // TOUCH / SIGHT (Short range)
            if(dist < 5 && !state.crouching) {
                state.figState = 'CHASE'; // He senses you close
                state.figTarget.copy(player.position);
            }

            // PATROL
            if(state.figState === 'PATROL') {
                if(figure.position.distanceTo(state.figTarget) < 2) {
                    // New random target
                    state.figTarget.set((Math.random()-0.5)*80, 0, (Math.random()-0.5)*80);
                }
            }

            // MOVEMENT
            const speed = state.figState === 'CHASE' ? 12.0 : 4.0;
            const dir = new THREE.Vector3().subVectors(state.figTarget, figure.position).normalize();
            dir.y = 0;

            // Simple Obstacle Avoidance (Raycasting feel)
            obstacles.forEach(ob => {
                if(figure.position.distanceTo(ob.position) < 4) {
                    const push = new THREE.Vector3().subVectors(figure.position, ob.position).normalize();
                    dir.add(push.multiplyScalar(2));
                }
            });
            dir.normalize();

            figure.position.addScaledVector(dir, speed * dt);
            figure.lookAt(state.figTarget.x, 3, state.figTarget.z);
            
            // Animation
            figure.position.y = Math.sin(Date.now() * 0.01) * 0.2;

            // DEATH
            if(dist < 1.5) kill();
        }

        function kill() {
            state.dead = true;
            document.exitPointerLock();
            playSound('scream');
            
            // Scary Face
            const scare = document.getElementById('jumpscare');
            scare.style.display = 'flex';
            const img = document.createElement('img');
            img.src = 'https://media.tenor.com/2Xy3l5sA1eAAAAAC/roblox-doors.gif'; // Generic scare gif
            img.id = 'scare-face';
            scare.appendChild(img);

            setTimeout(() => {
                alert("CAUGHT! Don't run when he is near.");
                location.reload();
            }, 1800);
        }

        // --- INTERACTION ---
        const raycaster = new THREE.Raycaster();
        function interact() {
            if(state.dead) return;
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const hits = raycaster.intersectObjects(interactables, true);

            if(hits.length > 0 && hits[0].distance < 5) {
                let obj = hits[0].object;
                while(!obj.userData.type && obj.parent) obj = obj.parent;

                if(obj.userData.type === 'breaker') {
                    playSound('collect');
                    state.fuses++;
                    obj.position.y = -50; // Hide
                    document.getElementById('obj-count').innerText = `${state.fuses} / 10`;
                }
                else if(obj.userData.type === 'exit') {
                    if(state.fuses >= 10) {
                        alert("ESCAPED THE LIBRARY!");
                        location.reload();
                    }
                }
            }
        }

        // --- LOOP ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();

            // Player Move
            if(controls.isLocked && !state.dead) {
                const moveSpeed = state.crouching ? 3.0 : 7.0;
                const dir = new THREE.Vector3();
                const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); fwd.y=0; fwd.normalize();
                const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion); right.y=0; right.normalize();

                if(keys.w) dir.add(fwd); if(keys.s) dir.sub(fwd);
                if(keys.a) dir.sub(right); if(keys.d) dir.add(right);

                if(dir.length()>0) {
                    dir.normalize();
                    player.position.addScaledVector(dir, moveSpeed * dt);
                }
            }

            if(figure.parent) updateFigure(dt);

            // Raycast UI
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const hits = raycaster.intersectObjects(interactables, true);
            const uiText = document.getElementById('interact-msg');
            if(hits.length > 0 && hits[0].distance < 5) {
                uiText.style.opacity = 1;
                const t = hits[0].object.userData.type || hits[0].object.parent.userData.type;
                uiText.innerText = (t==='breaker') ? "[E] COLLECT BREAKER" : (state.fuses>=10 ? "[E] ESCAPE" : "[E] LOCKED");
                if(t === 'exit' && state.fuses < 10) uiText.style.color = 'red';
                else uiText.style.color = 'white';
            } else {
                uiText.style.opacity = 0;
            }

            renderer.render(scene, camera);
        }
        animate();
        window.onresize = () => { camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); };

    </script>
</body>
</html>
