<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DOORS: LIGHTS ON EDITION</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: 'Segoe UI', Tahoma, sans-serif; user-select: none; }
        
        /* UI OVERLAY */
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; pading: 20px; }
        
        #top-bar { padding: 20px; color: white; display: flex; justify-content: space-between; font-weight: bold; text-shadow: 1px 1px 2px black; }
        #objective { color: #fbbf24; font-size: 20px; }
        
        #center { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); display: flex; flex-direction: column; align-items: center; }
        #crosshair { width: 8px; height: 8px; background: rgba(255, 255, 255, 0.9); border-radius: 50%; border: 1px solid black; }
        #interact { margin-top: 15px; color: white; font-weight: bold; font-size: 18px; text-shadow: 0 0 4px black; opacity: 0; transition: opacity 0.2s; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 4px; }

        /* POSTURE INDICATOR */
        #posture-icon {
            position: absolute; bottom: 20px; right: 20px; width: 50px; height: 50px;
            background: rgba(0,0,0,0.5); color: white; border-radius: 8px;
            display: flex; align-items: center; justify-content: center;
            font-size: 24px; border: 2px solid #555;
        }

        /* START SCREEN */
        #start {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #333; color: white; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer;
        }
        h1 { margin: 0; font-size: 50px; color: #fbbf24; }
        .keys { display: grid; grid-template-columns: auto 1fr; gap: 10px 20px; margin-top: 30px; text-align: left; background: rgba(0,0,0,0.2); padding: 20px; border-radius: 10px; }
        b { color: #fbbf24; }
    </style>
</head>
<body>

    <div id="start">
        <h1>DOORS: LIGHTS ON</h1>
        <p>[ CLICK TO PLAY ]</p>
        <div class="keys">
            <b>WASD</b> <span>Move Character</span>
            <b>C</b> <span>Crouch / Stand</span>
            <b>SHIFT</b> <span>Sprint</span>
            <b>E</b> <span>Interact</span>
        </div>
    </div>

    <div id="ui">
        <div id="top-bar">
            <span>DOOR 100 (TRAINING)</span>
            <span id="objective">FUSES: 0 / 10</span>
        </div>
        <div id="center">
            <div id="crosshair"></div>
            <div id="interact">[E] INTERACT</div>
        </div>
        <div id="posture-icon">üèÉ</div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x505050); // Grey background, not black
        // remove fog or make it very far
        scene.fog = new THREE.Fog(0x505050, 20, 60); 

        // --- LIGHTING (Make it bright!) ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); // High intensity ambient
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
        const renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- PLAYER CONTROLLER ---
        const controls = new PointerLockControls(camera, document.body);
        const player = new THREE.Group();
        player.add(camera);
        scene.add(player);
        player.position.set(0, 1.7, 5); // Start height

        // HAND MODEL
        const hand = new THREE.Group();
        const handMesh = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.25), new THREE.MeshStandardMaterial({color: 0xffdbac}));
        hand.add(handMesh);
        hand.position.set(0.4, -0.3, -0.5);
        camera.add(hand);

        // GAME STATE
        const keys = { w:0, a:0, s:0, d:0, shift:0 };
        const state = { 
            crouching: false, 
            targetHeight: 1.7, 
            currentHeight: 1.7,
            fuses: 0,
            dead: false
        };

        // --- LEVEL GENERATION (Door 100 Layout) ---
        const interactables = [];
        const walls = []; // For simple collision logic

        function createLevel() {
            // Floor
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(30, 40), new THREE.MeshStandardMaterial({color: 0x333333}));
            floor.rotation.x = -Math.PI/2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Ceiling (High visibility)
            const ceil = new THREE.Mesh(new THREE.PlaneGeometry(30, 40), new THREE.MeshStandardMaterial({color: 0xeeeeee}));
            ceil.rotation.x = Math.PI/2;
            ceil.position.y = 6;
            scene.add(ceil);

            // Walls Helper
            function addWall(w, h, d, x, y, z) {
                const wall = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({color: 0x666666}));
                wall.position.set(x, y, z);
                wall.castShadow = true;
                wall.receiveShadow = true;
                scene.add(wall);
                walls.push(wall); // Add to collision list
            }

            // Outer Walls
            addWall(1, 6, 40, -15, 3, 0); // Left
            addWall(1, 6, 40, 15, 3, 0); // Right
            addWall(30, 6, 1, 0, 3, -20); // Back
            addWall(30, 6, 1, 0, 3, 20); // Front

            // Shelves/Obstacles (To crouch behind)
            for(let i=0; i<6; i++) {
                const sx = (Math.random()-0.5) * 20;
                const sz = (Math.random()-0.5) * 30;
                addWall(4, 3, 1, sx, 1.5, sz);
            }

            // Breaker Box
            const box = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 0.5), new THREE.MeshStandardMaterial({color: 0x222222}));
            box.position.set(0, 2.5, -19.5);
            box.userData = { type: 'box' };
            interactables.push(box);
            scene.add(box);

            // 10 Fuses
            for(let i=0; i<10; i++) {
                const fuse = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.4), new THREE.MeshStandardMaterial({color: 0x00ff00}));
                fuse.rotation.z = Math.PI/2;
                fuse.position.set((Math.random()-0.5)*25, 0.5, (Math.random()-0.5)*35);
                fuse.userData = { type: 'fuse' };
                interactables.push(fuse);
                scene.add(fuse);
                
                // Add a glow so they are easy to see
                const glow = new THREE.PointLight(0x00ff00, 1, 3);
                fuse.add(glow);
            }
        }
        createLevel();

        // --- THE FIGURE (Simple AI) ---
        const figure = new THREE.Group();
        const fBody = new THREE.Mesh(new THREE.CapsuleGeometry(0.4, 1.8), new THREE.MeshStandardMaterial({color: 0x880000}));
        fBody.position.y = 0.9;
        const fHead = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshStandardMaterial({color: 0xaa0000}));
        fHead.position.y = 2.0;
        const fMouth = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.4), new THREE.MeshBasicMaterial({color: 0x000000}));
        fMouth.position.set(0, 2.0, 0.3);
        figure.add(fBody, fHead, fMouth);
        scene.add(figure);

        // --- EVENTS ---
        document.addEventListener('keydown', (e) => {
            if(e.code === 'KeyW') keys.w = 1;
            if(e.code === 'KeyA') keys.a = 1;
            if(e.code === 'KeyS') keys.s = 1;
            if(e.code === 'KeyD') keys.d = 1;
            if(e.code === 'ShiftLeft') keys.shift = 1;
            if(e.code === 'KeyC') toggleCrouch();
            if(e.code === 'KeyE') checkInteract();
        });
        document.addEventListener('keyup', (e) => {
            if(e.code === 'KeyW') keys.w = 0;
            if(e.code === 'KeyA') keys.a = 0;
            if(e.code === 'KeyS') keys.s = 0;
            if(e.code === 'KeyD') keys.d = 0;
            if(e.code === 'ShiftLeft') keys.shift = 0;
        });

        document.getElementById('start').onclick = () => {
            document.getElementById('start').style.display = 'none';
            controls.lock();
        };

        function toggleCrouch() {
            state.crouching = !state.crouching;
            state.targetHeight = state.crouching ? 0.6 : 1.7; // Lower camera to 0.6 when crouching
            document.getElementById('posture-icon').innerText = state.crouching ? 'üßé' : 'üèÉ';
        }

        const raycaster = new THREE.Raycaster();
        function checkInteract() {
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const hits = raycaster.intersectObjects(interactables);
            if(hits.length > 0 && hits[0].distance < 3) {
                const obj = hits[0].object;
                if(obj.userData.type === 'fuse') {
                    state.fuses++;
                    scene.remove(obj);
                    // remove from interactables array
                    const idx = interactables.indexOf(obj);
                    if(idx > -1) interactables.splice(idx, 1);
                    document.getElementById('objective').innerText = `FUSES: ${state.fuses} / 10`;
                }
                else if(obj.userData.type === 'box') {
                    if(state.fuses >= 10) {
                        alert("ELEVATOR POWERED! YOU WIN!");
                        location.reload();
                    } else {
                        alert("NEED MORE FUSES!");
                    }
                }
            }
        }

        // --- GAME LOOP ---
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();

            if(controls.isLocked && !state.dead) {
                // 1. CROUCH SMOOTHING
                // Lerp current height to target height
                state.currentHeight = THREE.MathUtils.lerp(state.currentHeight, state.targetHeight, 10 * dt);
                player.position.y = state.currentHeight;

                // 2. MOVEMENT
                // Speed depends on state
                let speed = 4.0;
                if(state.crouching) speed = 2.0;
                if(keys.shift && !state.crouching) speed = 7.0;

                const direction = new THREE.Vector3();
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                forward.y = 0; forward.normalize();
                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                right.y = 0; right.normalize();

                if(keys.w) direction.add(forward);
                if(keys.s) direction.sub(forward);
                if(keys.a) direction.sub(right);
                if(keys.d) direction.add(right);

                if(direction.length() > 0) {
                    direction.normalize();
                    // Simple wall collision check could go here, omitting for smoothness
                    player.position.addScaledVector(direction, speed * dt);
                    
                    // Hand Bobbing
                    const bobFreq = speed * 2;
                    hand.position.y = -0.3 + Math.sin(Date.now() * 0.01 * speed) * 0.02;
                }
            }

            // 3. FIGURE LOGIC
            // Simple circular patrol
            const time = Date.now() * 0.001;
            figure.position.x = Math.sin(time * 0.5) * 10;
            figure.position.z = Math.cos(time * 0.5) * 10;
            figure.lookAt(player.position.x, 1.5, player.position.z);
            
            // Detection
            const dist = player.position.distanceTo(figure.position);
            if(dist < 3) {
                if(!state.crouching && !state.dead) {
                    // Visual warning only in training mode
                    document.getElementById('objective').style.color = 'red';
                    document.getElementById('objective').innerText = "HE HEARS YOU! (CROUCH!)";
                } else if (dist < 1.5) {
                    // Caught
                    document.exitPointerLock();
                    alert("CAUGHT BY FIGURE! Reloading...");
                    location.reload();
                    state.dead = true;
                }
            } else {
                document.getElementById('objective').style.color = '#fbbf24';
            }


            // 4. INTERACTION UI
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const hits = raycaster.intersectObjects(interactables);
            const ui = document.getElementById('interact');
            if(hits.length > 0 && hits[0].distance < 3) {
                ui.style.opacity = 1;
                ui.innerText = hits[0].object.userData.type === 'fuse' ? "[E] TAKE FUSE" : "[E] USE BREAKER";
            } else {
                ui.style.opacity = 0;
            }

            renderer.render(scene, camera);
        }

        animate();

        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>
