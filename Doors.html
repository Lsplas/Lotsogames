<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DOORS: DOOR 100 UPDATE</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; user-select: none; }
        
        /* UI LAYERS */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; z-index: 10; }
        
        #top-bar { padding: 20px; display: flex; justify-content: space-between; align-items: flex-start; }
        #room-counter { font-size: 40px; color: #fbbf24; font-weight: bold; text-shadow: 0 0 10px #fbbf24; }
        #objective { color: #fff; font-size: 14px; text-shadow: 0 0 5px #000; margin-top: 5px;}
        
        #center-ui { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; }
        #crosshair { width: 6px; height: 6px; background: rgba(255, 255, 255, 0.8); border-radius: 50%; margin: 0 auto; box-shadow: 0 0 4px white; }
        #interact-text { margin-top: 20px; color: white; font-size: 18px; font-weight: bold; text-shadow: 0 0 5px black; opacity: 0; transition: opacity 0.2s; }

        /* JUMPSCARE */
        #jumpscare {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: black; display: none; align-items: center; justify-content: center; z-index: 100;
        }
        #jumpscare h1 { color: red; font-size: 100px; text-transform: uppercase; text-shadow: 0 0 20px red; text-align: center; }

        /* START SCREEN */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #050505; color: white; z-index: 200;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer;
        }
        h1 { margin: 0; font-size: 60px; color: #fbbf24; letter-spacing: 5px; }
        .controls { display: grid; grid-template-columns: 100px 1fr; gap: 10px; text-align: left; margin-top: 30px; color: #aaa; font-size: 14px; }
        #loading { color: #555; margin-top: 20px; font-size: 12px; }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1>DOORS</h1>
        <h2 style="color: #ef4444;">THE ELECTRICAL UPDATE</h2>
        <p>[ CLICK TO ENTER HOTEL ]</p>
        <div class="controls">
            <b>WASD</b> <span>Move</span>
            <b>C</b> <span>Crouch (Avoid Figure!)</span>
            <b>E</b> <span>Open / Collect Breakers</span>
            <b>F</b> <span>Lighter</span>
        </div>
        <div id="loading">Initializing assets...</div>
    </div>

    <div id="ui-layer">
        <div id="top-bar">
            <div>
                <div id="room-counter">000</div>
                <div id="objective">REACH DOOR 100</div>
            </div>
        </div>
        <div id="center-ui">
            <div id="crosshair"></div>
            <div id="interact-text">[E] INTERACT</div>
        </div>
    </div>

    <div id="jumpscare"><h1 id="death-msg">YOU DIED</h1></div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- 1. AUDIO ENGINE (Added Grumbles) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type, dist=1) {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;
            
            // Volume based on distance (simple attenuation)
            let vol = 0.5 / (dist > 0.5 ? dist : 1); 

            if(type === 'grumble') { 
                // FIGURE GRUMBLE (Low, guttural)
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(50, now);
                osc.frequency.linearRampToValueAtTime(30, now + 0.5);
                osc.frequency.linearRampToValueAtTime(40, now + 1.0);
                
                // Tremolo effect for "growl"
                const lfo = audioCtx.createOscillator();
                lfo.frequency.value = 15; // Fast rattle
                const lfoGain = audioCtx.createGain();
                lfoGain.gain.value = 500;
                lfo.connect(lfoGain.gain);
                
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(vol * 0.8, now + 0.2);
                gain.gain.linearRampToValueAtTime(0, now + 1.2);
                
                osc.start(now); osc.stop(now + 1.2);
            }
            else if(type === 'switch') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(400, now);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            }
            else if(type === 'pickup') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.2);
                osc.start(now); osc.stop(now + 0.2);
            }
            else if(type === 'wood') {
                // Generic interaction
                osc.frequency.setValueAtTime(100, now);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.start(now); osc.stop(now + 0.2);
            }
            else if(type === 'scream') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.linearRampToValueAtTime(800, now + 0.2);
                gain.gain.setValueAtTime(0.5, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.5);
                osc.start(now); osc.stop(now + 0.5);
            }
        }

        // --- 2. TEXTURES ---
        function createTex(color) {
            const c = document.createElement('canvas'); c.width = 64; c.height = 64;
            const x = c.getContext('2d');
            x.fillStyle = color; x.fillRect(0,0,64,64);
            // Noise
            for(let i=0; i<300; i++) {
                x.fillStyle = `rgba(0,0,0,${Math.random()*0.3})`;
                x.fillRect(Math.random()*64, Math.random()*64, 2, 2);
            }
            const t = new THREE.CanvasTexture(c);
            t.magFilter = THREE.NearestFilter;
            t.colorSpace = THREE.SRGBColorSpace;
            return t;
        }

        const texWall = createTex('#57534e');
        const texFloor = createTex('#292524');
        const texWood = createTex('#451a03');
        const texMetal = createTex('#3f3f46');

        // --- 3. SCENE & PLAYER & HAND ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.Fog(0x000000, 2, 20); // Thick darkness

        // Global Ambient Light (Prevents total black screen)
        const ambient = new THREE.AmbientLight(0xffffff, 0.1);
        scene.add(ambient);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 100);
        const renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const player = new THREE.Group();
        player.add(camera);
        scene.add(player);
        player.position.set(0, 1.6, 2);

        // --- THE HAND ---
        const handGroup = new THREE.Group();
        camera.add(handGroup);
        handGroup.position.set(0.4, -0.4, -0.5); // Bottom right
        handGroup.rotation.set(0.2, -0.2, 0);

        // Arm
        const arm = new THREE.Mesh(new THREE.CapsuleGeometry(0.08, 0.4), new THREE.MeshStandardMaterial({color: 0x111111})); // Dark sleeve
        arm.rotation.x = Math.PI/2;
        arm.position.z = 0.2;
        handGroup.add(arm);

        // Hand
        const handMesh = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.12, 0.05), new THREE.MeshStandardMaterial({color: 0xffccaa})); // Skin
        handMesh.position.z = -0.05;
        handGroup.add(handMesh);

        // Lighter
        const lighter = new THREE.Group();
        const lBody = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.1, 0.03), new THREE.MeshStandardMaterial({color: 0xaaaa00})); // Gold
        const lFlame = new THREE.PointLight(0xffaa00, 1, 8);
        lFlame.position.y = 0.1;
        lighter.add(lBody, lFlame);
        lighter.position.set(0, 0.05, -0.05);
        handGroup.add(lighter);

        // Hand Bobbing Logic
        let bobTimer = 0;

        // --- 4. GAME STATE ---
        const state = {
            room: 99, // START AT DOOR 99 to get to 100 fast
            breakersCollected: 0,
            breakersNeeded: 10,
            dead: false,
            crouching: false,
            door100Active: false
        };

        const interactables = [];
        const rooms = [];

        // --- 5. ROOM GENERATION ---
        function createRoom(index) {
            const is100 = (index === 100);
            const zPos = index * 15;
            const rGroup = new THREE.Group();
            rGroup.position.z = zPos;

            if(!is100) {
                // NORMAL CORRIDOR
                const w = 6; const d = 15; const h = 4;
                
                // Floor/Ceil
                const fl = new THREE.Mesh(new THREE.PlaneGeometry(w, d), new THREE.MeshStandardMaterial({map:texFloor}));
                fl.rotation.x = -Math.PI/2; fl.position.set(0,0,d/2); rGroup.add(fl);
                const cl = new THREE.Mesh(new THREE.PlaneGeometry(w, d), new THREE.MeshStandardMaterial({color:0x111111}));
                cl.rotation.x = Math.PI/2; cl.position.set(0,h,d/2); rGroup.add(cl);

                // Walls
                const w1 = new THREE.Mesh(new THREE.PlaneGeometry(d,h), new THREE.MeshStandardMaterial({map:texWall}));
                w1.rotation.y = Math.PI/2; w1.position.set(-w/2, h/2, d/2); rGroup.add(w1);
                const w2 = new THREE.Mesh(new THREE.PlaneGeometry(d,h), new THREE.MeshStandardMaterial({map:texWall}));
                w2.rotation.y = -Math.PI/2; w2.position.set(w/2, h/2, d/2); rGroup.add(w2);

                // Light
                const l = new THREE.PointLight(0xffaa55, 0.5, 10);
                l.position.set(0, 3.5, d/2); rGroup.add(l);

                // Next Door
                const door = new THREE.Mesh(new THREE.BoxGeometry(2.5, 3.5, 0.2), new THREE.MeshStandardMaterial({map:texWood}));
                door.position.set(0, 1.75, d);
                door.userData = { type: 'door', idx: index };
                rGroup.add(door);
                interactables.push(door);

                // Plate
                const canvas = document.createElement('canvas'); canvas.width=128; canvas.height=64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle='black'; ctx.fillRect(0,0,128,64);
                ctx.fillStyle='#fbbf24'; ctx.font='bold 40px Arial'; ctx.fillText((index+1).toString(), 40, 45);
                const plate = new THREE.Mesh(new THREE.PlaneGeometry(0.6, 0.3), new THREE.MeshBasicMaterial({map: new THREE.CanvasTexture(canvas)}));
                plate.position.set(0, 2.5, 0.11); door.add(plate);

            } else {
                // *** DOOR 100: ELECTRICAL ROOM ***
                const w = 20; const d = 30; const h = 6;
                state.door100Active = true;
                document.getElementById('objective').innerText = "FIND 10 BREAKERS / AVOID FIGURE";

                // Large Room
                const fl = new THREE.Mesh(new THREE.PlaneGeometry(w, d), new THREE.MeshStandardMaterial({map:texFloor}));
                fl.rotation.x = -Math.PI/2; fl.position.set(0,0,d/2); rGroup.add(fl);
                
                // Walls
                const wallMat = new THREE.MeshStandardMaterial({map:texMetal, side:THREE.DoubleSide});
                const wb = new THREE.Mesh(new THREE.PlaneGeometry(w, h), wallMat); // Back
                wb.position.set(0, h/2, d); wb.rotation.y=Math.PI; rGroup.add(wb);
                const wl = new THREE.Mesh(new THREE.PlaneGeometry(d, h), wallMat); // Left
                wl.position.set(-w/2, h/2, d/2); wl.rotation.y=Math.PI/2; rGroup.add(wl);
                const wr = new THREE.Mesh(new THREE.PlaneGeometry(d, h), wallMat); // Right
                wr.position.set(w/2, h/2, d/2); wr.rotation.y=-Math.PI/2; rGroup.add(wr);

                // Shelves & Obstacles
                for(let i=0; i<8; i++) {
                    const shelf = new THREE.Mesh(new THREE.BoxGeometry(2, 3, 6), new THREE.MeshStandardMaterial({map:texWood}));
                    const sx = (Math.random()-0.5) * (w-4);
                    const sz = 5 + Math.random() * (d-10);
                    shelf.position.set(sx, 1.5, sz);
                    shelf.castShadow = true;
                    rGroup.add(shelf);
                }

                // Breaker Box (Exit)
                const box = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 0.5), new THREE.MeshStandardMaterial({color:0x555555}));
                box.position.set(0, 2, d-0.5);
                box.userData = { type: 'breaker_box' };
                rGroup.add(box);
                interactables.push(box);

                // Spawn 10 Breakers
                for(let i=0; i<10; i++) {
                    const breaker = new THREE.Group();
                    const bMesh = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.5, 0.2), new THREE.MeshStandardMaterial({color: 0x00ff00, emissive: 0x004400}));
                    breaker.add(bMesh);
                    
                    // Random positions on floor/shelves
                    breaker.position.set(
                        (Math.random()-0.5) * 16,
                        0.5,
                        2 + Math.random() * 24
                    );
                    breaker.userData = { type: 'breaker' };
                    rGroup.add(breaker);
                    interactables.push(breaker);
                }

                // Spawn Figure
                initFigure(rGroup, w, d);
            }

            scene.add(rGroup);
            rooms.push(rGroup);
            if(rooms.length > 3) {
                const old = rooms.shift();
                scene.remove(old);
            }
        }

        // --- 6. THE FIGURE (DOOR 100) ---
        let figure = null;
        
        function initFigure(roomGroup, roomW, roomD) {
            figure = new THREE.Group();
            
            // Body (Ribcage style)
            const mat = new THREE.MeshStandardMaterial({color: 0x880000, roughness: 0.2});
            const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.3, 1.5, 8), mat);
            torso.position.y = 1.6;
            
            // Head (Mouth)
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.45), mat);
            head.position.y = 2.5;
            // Teeth
            const teeth = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.1, 0.4), new THREE.MeshBasicMaterial({color: 0xffffff}));
            teeth.position.set(0, 2.5, 0.3);
            
            // Limbs (Long arms)
            const armL = new THREE.Mesh(new THREE.BoxGeometry(0.15, 1.8, 0.15), mat);
            armL.position.set(-0.6, 1.8, 0.2); armL.rotation.z = 0.2;
            const armR = new THREE.Mesh(new THREE.BoxGeometry(0.15, 1.8, 0.15), mat);
            armR.position.set(0.6, 1.8, 0.2); armR.rotation.z = -0.2;

            figure.add(torso, head, teeth, armL, armR);
            figure.position.set(0, 0, 15); // Start mid room
            roomGroup.add(figure);
        }

        function updateFigure(dt, playerZLocal) {
            if(!figure) return;
            const time = Date.now() * 0.001;
            
            // Patrol Logic (Figure 8 pattern)
            const patrolX = Math.sin(time * 0.5) * 6;
            const patrolZ = 15 + Math.cos(time * 0.3) * 10;
            
            figure.position.x = patrolX;
            figure.position.z = patrolZ;
            figure.lookAt(player.position.x, 1.6, player.position.z); // Always faces player creepily

            // Bobbing animation
            figure.position.y = Math.abs(Math.sin(time * 5)) * 0.1;

            // Distance Check
            const dist = figure.getWorldPosition(new THREE.Vector3()).distanceTo(player.position);
            
            // Grumble Audio
            if(Math.random() < 0.02) { // Random chance every frame
                playSound('grumble', dist);
            }

            // Kill Logic
            if(dist < 2.5) {
                if(!state.crouching) {
                    die("FIGURE HEARD YOU RUNNING");
                } else if(dist < 1.0) {
                    die("FIGURE TOUCHED YOU");
                }
            }
        }

        function die(reason) {
            state.dead = true;
            document.exitPointerLock();
            document.getElementById('jumpscare').style.display = 'flex';
            document.getElementById('death-msg').innerText = reason;
            playSound('scream');
        }

        // --- 7. INPUT & LOOP ---
        const keys = { w:0, a:0, s:0, d:0 };
        const controls = new PointerLockControls(camera, document.body);
        const raycaster = new THREE.Raycaster();

        document.addEventListener('keydown', e => {
            if(e.code==='KeyW') keys.w=1; if(e.code==='KeyS') keys.s=1;
            if(e.code==='KeyA') keys.a=1; if(e.code==='KeyD') keys.d=1;
            if(e.code==='KeyC') { state.crouching=true; camera.position.y=1.0; }
            if(e.code==='KeyE') tryInteract();
        });
        document.addEventListener('keyup', e => {
            if(e.code==='KeyW') keys.w=0; if(e.code==='KeyS') keys.s=0;
            if(e.code==='KeyA') keys.a=0; if(e.code==='KeyD') keys.d=0;
            if(e.code==='KeyC') { state.crouching=false; camera.position.y=1.6; }
        });

        document.getElementById('start-screen').onclick = () => {
            controls.lock();
            document.getElementById('start-screen').style.display = 'none';
            // Init Room 99
            createRoom(99); 
        };

        function tryInteract() {
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const hits = raycaster.intersectObjects(interactables, true); // Recursive
            if(hits.length > 0 && hits[0].distance < 3.5) {
                // Traverse up to find user data
                let obj = hits[0].object;
                while(!obj.userData.type && obj.parent) obj = obj.parent;
                
                if(obj.userData.type === 'door') {
                    playSound('wood');
                    obj.position.x += 1.5;
                    obj.rotation.y = -Math.PI/2;
                    obj.userData.type = null; // Disable
                    state.room++;
                    document.getElementById('room-counter').innerText = state.room;
                    if(state.room === 100) createRoom(100);
                }
                else if(obj.userData.type === 'breaker') {
                    playSound('pickup');
                    state.breakersCollected++;
                    document.getElementById('objective').innerText = `BREAKERS: ${state.breakersCollected} / 10`;
                    scene.remove(obj); // Remove from scene
                    // Find in array and remove (hacky)
                    obj.position.y = -100; 
                }
                else if(obj.userData.type === 'breaker_box') {
                    if(state.breakersCollected >= 10) {
                        alert("YOU WIN! ELEVATOR POWERED.");
                        location.reload();
                    } else {
                        playSound('switch');
                        document.getElementById('objective').style.color = 'red';
                        setTimeout(()=>document.getElementById('objective').style.color='white', 200);
                    }
                }
            }
        }

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();

            if(!state.dead && controls.isLocked) {
                // Move
                const speed = state.crouching ? 2.5 : 6.0;
                const dir = new THREE.Vector3();
                const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); fwd.y=0; fwd.normalize();
                const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion); right.y=0; right.normalize();
                
                if(keys.w) dir.add(fwd); if(keys.s) dir.sub(fwd);
                if(keys.a) dir.sub(right); if(keys.d) dir.add(right);
                
                if(dir.length() > 0) {
                    dir.normalize();
                    player.position.addScaledVector(dir, speed * dt);
                    
                    // Hand Sway
                    bobTimer += dt * (state.crouching ? 5 : 10);
                    handGroup.position.y = -0.4 + Math.sin(bobTimer) * 0.02;
                    handGroup.position.x = 0.4 + Math.cos(bobTimer/2) * 0.02;
                }
            }

            // Figure Logic
            if(state.door100Active) {
                // Player Z relative to room 100 start
                const startZ = 100 * 15;
                if(player.position.z > startZ) {
                    updateFigure(dt, player.position.z - startZ);
                }
            }

            // Raycast UI
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const hits = raycaster.intersectObjects(interactables, true);
            const txt = document.getElementById('interact-text');
            if(hits.length>0 && hits[0].distance < 3.5) {
                let obj = hits[0].object;
                while(!obj.userData.type && obj.parent) obj = obj.parent;
                
                if(obj.userData.type === 'door') { txt.style.opacity=1; txt.innerText="[E] OPEN"; }
                else if(obj.userData.type === 'breaker') { txt.style.opacity=1; txt.innerText="[E] COLLECT FUSE"; }
                else if(obj.userData.type === 'breaker_box') { 
                    txt.style.opacity=1; 
                    txt.innerText = state.breakersCollected === 10 ? "[E] ACTIVATE ELEVATOR" : "[E] NEED MORE FUSES";
                }
                else { txt.style.opacity=0; }
            } else { txt.style.opacity=0; }

            renderer.render(scene, camera);
        }
        animate();

        window.onresize = () => { camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); };

    </script>
</body>
</html>
