<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DOORS: ROOM 50 UPDATE</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; user-select: none; }
        
        /* --- UI OVERLAYS --- */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        #top-bar { padding: 20px; display: flex; justify-content: space-between; align-items: flex-start; }
        #room-counter { font-size: 40px; color: #fbbf24; font-weight: bold; text-shadow: 0 0 10px #fbbf24; }
        #inventory { display: flex; gap: 10px; }
        .item { width: 50px; height: 50px; border: 2px solid #555; background: rgba(0,0,0,0.5); color: white; display: flex; align-items: center; justify-content: center; font-size: 24px; }
        .item.active { border-color: #fbbf24; box-shadow: 0 0 10px #fbbf24; }

        #center-ui { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; }
        #crosshair { width: 6px; height: 6px; background: rgba(255, 255, 255, 0.8); border-radius: 50%; margin: 0 auto; box-shadow: 0 0 4px white; }
        #interact-text { margin-top: 20px; color: white; font-size: 18px; font-weight: bold; text-shadow: 0 0 5px black; opacity: 0; transition: opacity 0.2s; }

        #bottom-bar { padding: 20px; text-align: center; color: #888; font-size: 14px; }

        /* HIDING OVERLAY */
        #hiding-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(90deg, #000 0%, #000 10%, transparent 15%, transparent 85%, #000 90%, #000 100%);
            z-index: 50; display: none; pointer-events: none;
        }

        /* JUMP SCARE */
        #jumpscare {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: black; display: none; align-items: center; justify-content: center; z-index: 100;
        }
        #jumpscare h1 { color: red; font-size: 100px; text-shadow: 0 0 20px red; }

        /* START SCREEN */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #050505; color: white; z-index: 200;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer;
        }
        h1 { margin: 0; font-size: 60px; color: #fbbf24; }
        .controls { display: grid; grid-template-columns: 100px 1fr; gap: 10px; text-align: left; margin-top: 30px; color: #aaa; }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1>DOORS 3D</h1>
        <h2 style="color: #ef4444;">THE FIGURE UPDATE</h2>
        <p>[ CLICK TO START ]</p>
        <div class="controls">
            <b>WASD</b> <span>Move</span>
            <b>SHIFT</b> <span>Sprint</span>
            <b>C</b> <span>Crouch (Essential for Door 50)</span>
            <b>E</b> <span>Open Door / Search Drawer / Hide</span>
            <b>F</b> <span>Toggle Lighter</span>
        </div>
    </div>

    <div id="ui-layer">
        <div id="top-bar">
            <div id="room-counter">000</div>
            <div id="inventory">
                <div id="inv-lighter" class="item">ðŸ”¥</div>
                <div id="inv-gold" class="item">ðŸŸ¡</div>
            </div>
        </div>
        <div id="center-ui">
            <div id="crosshair"></div>
            <div id="interact-text">[E] OPEN</div>
        </div>
        <div id="bottom-bar"></div>
    </div>

    <div id="hiding-screen"></div>
    <div id="jumpscare"><h1 id="death-msg">YOU DIED</h1></div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- 1. AUDIO ENGINE (Procedural) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if(type === 'wood') { // Door/Drawer
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.3);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
            }
            if(type === 'gold') { // Ding
                osc.type = 'sine'; osc.frequency.setValueAtTime(1200, now);
                gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                osc.start(now); osc.stop(now + 0.5);
            }
            if(type === 'heartbeat') { // Figure near
                osc.type = 'triangle'; osc.frequency.setValueAtTime(60, now);
                gain.gain.setValueAtTime(0.8, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                osc.start(now); osc.stop(now + 0.15);
            }
            if(type === 'scream') { // Jumpscare
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, now);
                osc.frequency.linearRampToValueAtTime(1000, now + 0.2);
                gain.gain.setValueAtTime(0.5, now); gain.gain.linearRampToValueAtTime(0, now + 0.5);
                osc.start(now); osc.stop(now + 0.5);
            }
        }

        // --- 2. TEXTURES ---
        function createTex(color, noise=false) {
            const c = document.createElement('canvas'); c.width = 64; c.height = 64;
            const x = c.getContext('2d');
            x.fillStyle = color; x.fillRect(0,0,64,64);
            if(noise) {
                for(let i=0;i<200;i++) {
                    x.fillStyle = `rgba(0,0,0,${Math.random()*0.2})`;
                    x.fillRect(Math.random()*64, Math.random()*64, 2, 2);
                }
            }
            const t = new THREE.CanvasTexture(c);
            t.magFilter = THREE.NearestFilter;
            return t;
        }
        const texWood = createTex('#5c4033', true);
        const texWall = createTex('#a8a29e', true);
        const texCarpet = createTex('#450a0a', true);
        const texGold = createTex('#fbbf24');

        // --- 3. SCENE & PLAYER ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        scene.fog = new THREE.Fog(0x000000, 2, 15);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 100);
        const renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new PointerLockControls(camera, document.body);
        const player = new THREE.Group();
        player.add(camera); scene.add(player);
        player.position.set(0, 1.6, 2);

        // Player State
        const state = { 
            room: 0, 
            hiding: false, 
            crouching: false, 
            dead: false, 
            hasLighter: false, 
            lighterOn: false, 
            gold: 0 
        };

        // Lighter Light
        const lighterLight = new THREE.PointLight(0xffaa00, 0, 10);
        camera.add(lighterLight); lighterLight.position.set(0.3, -0.3, 0.5);

        // --- 4. ASSETS (Drawers, Wardrobes) ---
        function createFurniture(type, x, y, z, parent) {
            const group = new THREE.Group();
            group.position.set(x, y, z);
            
            if(type === 'wardrobe') {
                const body = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3, 1), new THREE.MeshStandardMaterial({map: texWood}));
                body.castShadow = true;
                group.add(body);
                // Doors
                const dL = new THREE.Mesh(new THREE.BoxGeometry(0.7, 2.9, 0.1), new THREE.MeshStandardMaterial({map: texWood, color: 0x443322}));
                dL.position.set(-0.35, 0, 0.5); group.add(dL);
                const dR = new THREE.Mesh(new THREE.BoxGeometry(0.7, 2.9, 0.1), new THREE.MeshStandardMaterial({map: texWood, color: 0x443322}));
                dR.position.set(0.35, 0, 0.5); group.add(dR);
                group.userData = { type: 'wardrobe' };
            }
            else if(type === 'drawer') {
                // Cabinet
                const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.5, 1), new THREE.MeshStandardMaterial({map: texWood, color: 0x332211}));
                body.castShadow = true; group.add(body);
                // 3 Drawers
                for(let i=0; i<3; i++) {
                    const d = new THREE.Mesh(new THREE.BoxGeometry(1, 0.4, 0.9), new THREE.MeshStandardMaterial({map: texWood}));
                    d.position.set(0, 0.4 - (i*0.45), 0.1);
                    d.userData = { type: 'drawer_slot', open: false, loot: Math.random() > 0.7 ? (Math.random()>0.5?'gold':'lighter') : null };
                    
                    // Knob
                    const k = new THREE.Mesh(new THREE.SphereGeometry(0.05), new THREE.MeshBasicMaterial({color:0xffd700}));
                    k.position.set(0, 0, 0.5); d.add(k);
                    
                    group.add(d);
                }
            }
            parent.add(group);
            return group;
        }

        // --- 5. ROOM GENERATION ---
        const rooms = [];
        const interactables = [];
        
        function generateRoom(index) {
            const isBoss = (index === 50);
            const depth = isBoss ? 30 : 12;
            const width = isBoss ? 15 : 6;
            const zPos = index * 12; // Simple linear generation for prototype
            
            const rGroup = new THREE.Group();
            rGroup.position.z = zPos;

            // Walls/Floor
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(width, depth), new THREE.MeshStandardMaterial({map: texCarpet}));
            floor.rotation.x = -Math.PI/2; floor.position.set(0,0,depth/2); rGroup.add(floor);
            
            const ceil = new THREE.Mesh(new THREE.PlaneGeometry(width, depth), new THREE.MeshStandardMaterial({color:0x111111}));
            ceil.rotation.x = Math.PI/2; ceil.position.set(0,4,depth/2); rGroup.add(ceil);

            const wMat = new THREE.MeshStandardMaterial({map: texWall, side: THREE.DoubleSide});
            const wL = new THREE.Mesh(new THREE.PlaneGeometry(depth, 4), wMat);
            wL.rotation.y = Math.PI/2; wL.position.set(-width/2, 2, depth/2); rGroup.add(wL);
            const wR = new THREE.Mesh(new THREE.PlaneGeometry(depth, 4), wMat);
            wR.rotation.y = -Math.PI/2; wR.position.set(width/2, 2, depth/2); rGroup.add(wR);

            // Lighting
            const light = new THREE.PointLight(0xffaa55, 1, 10);
            light.position.set(0, 3.5, depth/2);
            light.castShadow = true;
            rGroup.add(light);
            rGroup.userData = { light: light, index: index };

            // Exit Door (If not boss room mid)
            if(!isBoss) {
                const door = new THREE.Mesh(new THREE.BoxGeometry(2.2, 3, 0.2), new THREE.MeshStandardMaterial({map: texWood}));
                door.position.set(0, 1.5, depth);
                door.userData = { type: 'door', open: false, idx: index };
                rGroup.add(door);
                interactables.push(door);
                
                // Door Number
                const canvas = document.createElement('canvas'); canvas.width=128; canvas.height=64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle='black'; ctx.fillRect(0,0,128,64);
                ctx.fillStyle='gold'; ctx.font='40px Arial'; ctx.fillText((index+1).toString(), 40, 45);
                const plate = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 0.25), new THREE.MeshBasicMaterial({map: new THREE.CanvasTexture(canvas)}));
                plate.position.set(0, 2, 0.15); door.add(plate);

                // Furniture Spawning
                if(Math.random() > 0.3) createFurniture('wardrobe', (width/2)-1, 1.5, depth/2, rGroup).children.forEach(c=>interactables.push(c.parent));
                if(Math.random() > 0.5) createFurniture('drawer', -(width/2)+1, 0.8, depth/2 + 2, rGroup).children.forEach(c=> { if(c.userData.type) interactables.push(c); });
            } else {
                // ROOM 50 SETUP
                initFigure(rGroup, zPos, width, depth);
            }

            scene.add(rGroup);
            rooms.push(rGroup);
            if(rooms.length > 4) { scene.remove(rooms.shift()); } // Cleanup
        }

        // --- 6. THE FIGURE (ROOM 50 BOSS) ---
        let figure = null;
        let figureActive = false;
        
        function initFigure(roomGroup, zStart, w, d) {
            // Figure Mesh (Scary Red Monster)
            const mat = new THREE.MeshStandardMaterial({color: 0x880000, roughness: 0.2});
            figure = new THREE.Group();
            const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.5, 2, 4, 8), mat);
            body.position.y = 1.5;
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.4), new THREE.MeshStandardMaterial({color: 0xaa0000, teeth:true})); // "Mouth"
            head.position.y = 2.8;
            
            // Big Mouth (Visual)
            const mouth = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.2, 0.5), new THREE.MeshBasicMaterial({color:0x000000}));
            mouth.position.set(0, 2.8, 0.3);
            figure.add(body, head, mouth);
            
            figure.position.set(0, 0, zStart + d/2);
            scene.add(figure);
            figureActive = true;
            
            // Add Pillars/Bookshelves to hide behind
            for(let x=-4; x<=4; x+=4) {
                for(let z=5; z<25; z+=8) {
                    const shelf = new THREE.Mesh(new THREE.BoxGeometry(2, 3, 4), new THREE.MeshStandardMaterial({map:texWood, color:0x332211}));
                    shelf.position.set(x, 1.5, zStart + z);
                    shelf.castShadow = true;
                    scene.add(shelf); // Add to scene to block Figure logic? (Simplified: just visual)
                }
            }
            
            // Exit Door 51
            const door51 = new THREE.Mesh(new THREE.BoxGeometry(3, 4, 0.2), new THREE.MeshStandardMaterial({map: texWood}));
            door51.position.set(0, 2, zStart + d);
            door51.userData = { type: 'door', open: false, idx: 50 };
            scene.add(door51);
            interactables.push(door51);
        }

        // --- 7. ENTITY LOGIC (Rush & Figure) ---
        let rushActive = false;
        const rushMesh = new THREE.Mesh(new THREE.SphereGeometry(3), new THREE.MeshBasicMaterial({color:0x111111}));
        scene.add(rushMesh); rushMesh.position.y = -100;

        function updateEntities(dt) {
            if(state.dead) return;

            // RUSH MECHANIC (Random Spawn)
            if(!rushActive && state.room < 49 && Math.random() < 0.001) {
                rushActive = true;
                // Flicker Lights
                let fCount = 0;
                const flick = setInterval(()=>{
                    rooms.forEach(r=>{ if(r.userData.light) r.userData.light.intensity = Math.random()>0.5?0.1:1; });
                    fCount++;
                    if(fCount>30) { clearInterval(flick); rooms.forEach(r=>{if(r.userData.light)r.userData.light.intensity=1}); spawnRush(); }
                }, 100);
            }

            function spawnRush() {
                const zStart = (state.room - 2) * 12;
                const zEnd = (state.room + 3) * 12;
                let progress = 0;
                playSound('scream'); // Distant scream
                
                const interval = setInterval(()=>{
                    if(state.dead) { clearInterval(interval); return; }
                    progress += 0.02;
                    rushMesh.position.set(0, 2, THREE.MathUtils.lerp(zStart, zEnd, progress));
                    
                    // Kill Check
                    if(Math.abs(rushMesh.position.z - player.position.z) < 5) {
                        if(!state.hiding) die("RUSH CAUGHT YOU");
                    }
                    if(progress>=1) {
                        clearInterval(interval); rushActive = false; rushMesh.position.y=-100;
                    }
                }, 16);
            }

            // FIGURE MECHANIC (Blind AI)
            if(figureActive && figure) {
                const time = Date.now() * 0.001;
                // Patrol Circle
                const zCenter = 50 * 12 + 15;
                figure.position.x = Math.sin(time) * 5;
                figure.position.z = zCenter + Math.cos(time) * 10;
                figure.rotation.y = Math.atan2(Math.cos(time), -Math.sin(time));

                // Detection Logic
                const dist = player.position.distanceTo(figure.position);
                
                if(dist < 15) {
                    // Heartbeat sound
                    if(Math.random() < 0.1) playSound('heartbeat');
                    
                    // Kill Logic
                    // If close AND moving fast (not crouching)
                    const isMoving = (keys.w||keys.a||keys.s||keys.d);
                    const isSafe = state.crouching || !isMoving || state.hiding;
                    
                    if(dist < 4 && !isSafe) {
                        die("THE FIGURE HEARD YOU");
                    }
                    // If VERY close, you die anyway unless hiding
                    if(dist < 1.5 && !state.hiding) {
                        die("THE FIGURE TOUCHED YOU");
                    }
                }
            }
        }

        function die(reason) {
            state.dead = true;
            document.exitPointerLock();
            document.getElementById('jumpscare').style.display = 'flex';
            document.getElementById('death-msg').innerText = reason;
            playSound('scream');
        }

        // --- 8. INPUT & INTERACTION ---
        const keys = { w:0, a:0, s:0, d:0 };
        const raycaster = new THREE.Raycaster();

        document.addEventListener('keydown', e => {
            if(e.code === 'KeyW') keys.w=1; if(e.code === 'KeyS') keys.s=1;
            if(e.code === 'KeyA') keys.a=1; if(e.code === 'KeyD') keys.d=1;
            if(e.code === 'KeyC') { state.crouching = true; camera.position.y = 0.8; }
            if(e.code === 'ShiftLeft') state.sprinting = true;
            if(e.code === 'KeyE') interact();
            if(e.code === 'KeyF') { 
                if(state.hasLighter) { 
                    state.lighterOn = !state.lighterOn; 
                    lighterLight.intensity = state.lighterOn ? 1.5 : 0; 
                    document.getElementById('inv-lighter').classList.toggle('active');
                }
            }
        });
        document.addEventListener('keyup', e => {
            if(e.code === 'KeyW') keys.w=0; if(e.code === 'KeyS') keys.s=0;
            if(e.code === 'KeyA') keys.a=0; if(e.code === 'KeyD') keys.d=0;
            if(e.code === 'KeyC') { state.crouching = false; camera.position.y = 1.6; }
            if(e.code === 'ShiftLeft') state.sprinting = false;
        });

        document.getElementById('start-screen').onclick = () => {
            controls.lock();
            document.getElementById('start-screen').style.display = 'none';
            generateRoom(0); generateRoom(1);
        };

        function interact() {
            if(state.dead) return;
            
            // Exit Hiding
            if(state.hiding) {
                state.hiding = false;
                player.position.copy(state.hidePos);
                player.position.add(new THREE.Vector3(0,0,1)); // Step out
                document.getElementById('hiding-screen').style.display = 'none';
                return;
            }

            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const hits = raycaster.intersectObjects(interactables);
            
            if(hits.length > 0 && hits[0].distance < 3) {
                const obj = hits[0].object;
                const data = obj.userData;

                if(data.type === 'door' && !data.open) {
                    playSound('wood');
                    // Open anim
                    const targetRot = obj.rotation.y - Math.PI/2;
                    obj.rotation.y = targetRot;
                    obj.position.x += 1; // Pivot fake
                    data.open = true;
                    state.room++;
                    document.getElementById('room-counter').innerText = state.room.toString().padStart(3,'0');
                    if(state.room < 50) generateRoom(state.room + 1);
                }
                else if(data.type === 'wardrobe') {
                    state.hiding = true;
                    state.hidePos = player.position.clone();
                    player.position.copy(obj.parent.position);
                    player.rotation.y = Math.PI; // Face out
                    document.getElementById('hiding-screen').style.display = 'block';
                }
                else if(data.type === 'drawer_slot' && !data.open) {
                    playSound('wood');
                    obj.position.z += 0.3; // Slide out
                    data.open = true;
                    if(data.loot) {
                        playSound('gold');
                        if(data.loot === 'gold') {
                            state.gold += 10;
                            document.getElementById('bottom-bar').innerText = "+10 GOLD";
                        } else if(data.loot === 'lighter') {
                            state.hasLighter = true;
                            document.getElementById('inv-lighter').style.opacity = 1;
                            document.getElementById('bottom-bar').innerText = "FOUND LIGHTER [F]";
                        }
                    }
                }
            }
        }

        // --- 9. LOOP ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.1);

            if(!state.dead && !state.hiding && controls.isLocked) {
                const speed = state.crouching ? 2 : (state.sprinting ? 8 : 4.5);
                const dir = new THREE.Vector3();
                const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); fwd.y=0; fwd.normalize();
                const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion); right.y=0; right.normalize();
                
                if(keys.w) dir.add(fwd); if(keys.s) dir.sub(fwd);
                if(keys.a) dir.sub(right); if(keys.d) dir.add(right);
                if(dir.length()>0) dir.normalize();

                player.position.addScaledVector(dir, speed * dt);
            }

            // Raycast UI Update
            if(!state.hiding) {
                raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
                const hits = raycaster.intersectObjects(interactables);
                const txt = document.getElementById('interact-text');
                if(hits.length>0 && hits[0].distance < 3) {
                    txt.style.opacity = 1;
                    const t = hits[0].object.userData.type;
                    if(t==='door') txt.innerText = "[E] OPEN";
                    if(t==='wardrobe') txt.innerText = "[E] HIDE";
                    if(t==='drawer_slot') txt.innerText = "[E] SEARCH";
                } else { txt.style.opacity = 0; }
            } else {
                document.getElementById('interact-text').innerText = "[E] LEAVE";
                document.getElementById('interact-text').style.opacity = 1;
            }

            updateEntities(dt);
            renderer.render(scene, camera);
        }
        animate();
        
        window.onresize = () => { camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); };
    </script>
</body>
</html>
