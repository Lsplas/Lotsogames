<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ultimate Obby v4.0</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; user-select: none; }
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; padding: 20px; box-sizing: border-box;
        }
        .hud-item {
            color: white; text-shadow: 2px 2px 0 #000; font-weight: bold; font-size: 24px; margin-bottom: 10px;
        }
        #center-crosshair {
            position: absolute; top: 50%; left: 50%; width: 10px; height: 10px;
            background: white; border-radius: 50%; transform: translate(-50%, -50%);
            border: 2px solid black; opacity: 0.8;
        }
        #title-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: flex; flex-direction: column;
            align-items: center; justify-content: center; color: white; pointer-events: auto; z-index: 999;
        }
        h1 { font-size: 60px; margin: 0; color: #00d26a; text-shadow: 0 0 20px #00d26a; }
        p { font-size: 20px; color: #ccc; margin-bottom: 30px; }
        button {
            padding: 15px 50px; font-size: 24px; background: white; border: none;
            color: #333; cursor: pointer; border-radius: 50px; font-weight: bold;
            transition: all 0.2s;
        }
        button:hover { transform: scale(1.1); box-shadow: 0 0 20px white; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-item">LEVEL: <span id="level-txt" style="color:#00d26a">1</span></div>
        <div class="hud-item">DEATHS: <span id="death-txt" style="color:#ff4444">0</span></div>
    </div>
    <div id="center-crosshair"></div>

    <div id="title-screen">
        <h1>MASTER OBBY</h1>
        <p>WASD to Move • SPACE to Jump • CLICK to Start</p>
        <button id="start-btn">PLAY NOW</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- 1. AUDIO ENGINE (Synthesized Sounds) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            if (type === 'jump') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(300, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(500, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.start(); osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'die') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.3);
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                osc.start(); osc.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'check') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, audioCtx.currentTime);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                osc.start(); osc.stop(audioCtx.currentTime + 0.1);
                
                setTimeout(() => {
                    const osc2 = audioCtx.createOscillator();
                    const gain2 = audioCtx.createGain();
                    osc2.connect(gain2);
                    gain2.connect(audioCtx.destination);
                    osc2.frequency.setValueAtTime(900, audioCtx.currentTime);
                    gain2.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gain2.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    osc2.start(); osc2.stop(audioCtx.currentTime + 0.2);
                }, 100);
            }
        }

        // --- 2. PARTICLE SYSTEM ---
        const particles = [];
        function createExplosion(x, y, z, color) {
            for(let i=0; i<20; i++) {
                const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const mat = new THREE.MeshBasicMaterial({ color: color });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(x, y, z);
                
                // Random velocity
                const vel = new THREE.Vector3(
                    (Math.random()-0.5)*10, 
                    (Math.random())*10, 
                    (Math.random()-0.5)*10
                );
                
                scene.add(mesh);
                particles.push({ mesh, vel, life: 1.0 });
            }
        }

        // --- 3. SCENE & TEXTURES ---
        function createGridTexture(c1, c2) {
            const cvs = document.createElement('canvas'); cvs.width = 64; cvs.height = 64;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = c1; ctx.fillRect(0,0,64,64);
            ctx.fillStyle = c2; ctx.fillRect(0,0,32,32); ctx.fillRect(32,32,32,32);
            const tex = new THREE.CanvasTexture(cvs);
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            tex.magFilter = THREE.NearestFilter;
            return tex;
        }

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0x404040, 1.5); // Soft white light
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2); // Sun
        dirLight.position.set(20, 50, 30);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // --- 4. PLAYER ---
        const playerGroup = new THREE.Group();
        scene.add(playerGroup);

        const skinMat = new THREE.MeshStandardMaterial({ color: 0xffd700 });
        const torsoMat = new THREE.MeshStandardMaterial({ color: 0x0088ff });
        const legMat = new THREE.MeshStandardMaterial({ color: 0x4caf50 });

        const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), skinMat); head.position.y = 1.75;
        const torso = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.4), torsoMat); torso.position.y = 1.1;
        const lLeg = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.8, 0.3), legMat); lLeg.position.set(-0.2, 0.4, 0);
        const rLeg = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.8, 0.3), legMat); rLeg.position.set(0.2, 0.4, 0);
        const lArm = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 0.25), skinMat); lArm.position.set(-0.55, 1.1, 0);
        const rArm = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 0.25), skinMat); rArm.position.set(0.55, 1.1, 0);

        [head, torso, lLeg, rLeg, lArm, rArm].forEach(m => { m.castShadow = true; playerGroup.add(m); });

        // --- 5. WORLD ---
        const platforms = [];
        const movingObjects = [];
        const texSpawn = createGridTexture('#888', '#999');
        const texLava = createGridTexture('#ff0000', '#aa0000');
        const texCheck = createGridTexture('#ffff00', '#ddaa00');

        function createPart(w, h, d, x, y, z, type, moveData = null) {
            let mat = new THREE.MeshStandardMaterial({ map: texSpawn });
            if(type === 'lava') mat = new THREE.MeshStandardMaterial({ map: texLava, emissive: 0x550000 });
            if(type === 'check') mat = new THREE.MeshStandardMaterial({ map: texCheck });

            mat.map.repeat.set(w/2, d/2);
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
            mesh.position.set(x, y, z);
            mesh.receiveShadow = true;
            mesh.castShadow = true;
            mesh.userData = { type, move: moveData };
            scene.add(mesh);
            platforms.push(mesh);
            if(moveData) movingObjects.push(mesh);
        }

        // LEVEL 1
        createPart(10, 1, 10, 0, 0, 0, 'spawn');
        createPart(3, 1, 3, 0, 1, 10, 'base');
        createPart(3, 1, 3, 0, 2, 17, 'base');
        createPart(3, 1, 3, 0, 3, 24, 'base');
        createPart(8, 1, 8, 0, 4, 32, 'check'); // Checkpoint 1

        // LEVEL 2 (Moving)
        createPart(4, 0.5, 4, 0, 4, 42, 'base', { type: 'slide', axis: 'x', range: 5, speed: 2 });
        createPart(4, 0.5, 4, 0, 5, 52, 'base', { type: 'slide', axis: 'x', range: 5, speed: -2 });
        createPart(8, 1, 8, 0, 6, 62, 'check'); // Checkpoint 2

        // LEVEL 3 (Spinning Beams)
        createPart(2, 1, 25, 0, 6, 80, 'base');
        createPart(10, 1, 1, 0, 7.5, 80, 'lava', { type: 'spin', speed: 2 }); // Spinner
        createPart(10, 1, 1, 0, 7.5, 90, 'lava', { type: 'spin', speed: -3 }); // Spinner
        
        createPart(15, 1, 15, 0, 6, 110, 'check'); // WIN

        // Floor Lava
        createPart(300, 1, 300, 0, -10, 50, 'lava');

        // --- 6. GAME LOGIC ---
        let velocity = new THREE.Vector3();
        let spawnPos = new THREE.Vector3(0, 5, 0);
        let deaths = 0;
        let canJump = false;
        
        const controls = new PointerLockControls(camera, document.body);
        document.getElementById('start-btn').onclick = () => {
            controls.lock(); 
            document.getElementById('title-screen').style.display = 'none';
            if (audioCtx.state === 'suspended') audioCtx.resume();
        };

        const keys = { w:0, a:0, s:0, d:0 };
        document.addEventListener('keydown', (e) => {
            if(e.code === 'KeyW') keys.w = 1;
            if(e.code === 'KeyS') keys.s = 1;
            if(e.code === 'KeyA') keys.a = 1;
            if(e.code === 'KeyD') keys.d = 1;
            if(e.code === 'Space' && canJump) { 
                velocity.y = 16; 
                canJump = false; 
                playSound('jump');
            }
            if(e.code === 'KeyR') die();
        });
        document.addEventListener('keyup', (e) => {
            if(e.code === 'KeyW') keys.w = 0;
            if(e.code === 'KeyS') keys.s = 0;
            if(e.code === 'KeyA') keys.a = 0;
            if(e.code === 'KeyD') keys.d = 0;
        });

        function die() {
            playSound('die');
            createExplosion(playerGroup.position.x, playerGroup.position.y, playerGroup.position.z, 0xffff00);
            playerGroup.visible = false;
            setTimeout(() => {
                playerGroup.position.copy(spawnPos);
                velocity.set(0,0,0);
                playerGroup.visible = true;
                deaths++;
                document.getElementById('death-txt').innerText = deaths;
            }, 1000);
        }

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.1);
            const time = Date.now() * 0.001;

            // Update Moving Objects
            movingObjects.forEach(obj => {
                const m = obj.userData.move;
                if(m.type === 'slide') {
                    if(m.axis === 'x') obj.position.x = Math.sin(time * m.speed) * m.range;
                } else if (m.type === 'spin') {
                    obj.rotation.y += m.speed * delta;
                }
            });

            // Update Particles
            for(let i = particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.mesh.position.add(p.vel.clone().multiplyScalar(delta));
                p.vel.y -= 20 * delta; // Gravity
                p.life -= delta;
                p.mesh.scale.setScalar(p.life);
                if(p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }

            if (controls.isLocked && playerGroup.visible) {
                // Physics
                velocity.y -= 40 * delta; // Gravity
                
                // Movement
                const speed = 200 * delta;
                const dir = new THREE.Vector3();
                const camDir = new THREE.Vector3();
                camera.getWorldDirection(camDir);
                camDir.y = 0; camDir.normalize();
                
                const camSide = new THREE.Vector3().crossVectors(camera.up, camDir).normalize();
                
                if (keys.w) dir.add(camDir);
                if (keys.s) dir.sub(camDir);
                if (keys.a) dir.add(camSide);
                if (keys.d) dir.sub(camSide);
                
                if (dir.lengthSq() > 0) dir.normalize();
                
                velocity.x -= velocity.x * 10 * delta; // Friction
                velocity.z -= velocity.z * 10 * delta;
                
                velocity.x += dir.x * speed;
                velocity.z += dir.z * speed;

                playerGroup.position.x += velocity.x * delta;
                playerGroup.position.z += velocity.z * delta;
                playerGroup.position.y += velocity.y * delta;

                // Collision
                const playerBox = new THREE.Box3().setFromObject(torso);
                let onGround = false;

                platforms.forEach(p => {
                    const pBox = new THREE.Box3().setFromObject(p);
                    if (playerBox.intersectsBox(pBox)) {
                        // Check if hitting lava
                        if (p.userData.type === 'lava') {
                             die();
                        } 
                        // Land on top
                        else if (velocity.y < 0 && playerGroup.position.y > pBox.max.y - 0.5) {
                            playerGroup.position.y = pBox.max.y;
                            velocity.y = 0;
                            onGround = true;
                            canJump = true;
                            
                            // Checkpoint Logic
                            if (p.userData.type === 'check') {
                                if (p.position.z > spawnPos.z + 1) { // New checkpoint
                                    spawnPos.copy(p.position).add(new THREE.Vector3(0,5,0));
                                    playSound('check');
                                    document.getElementById('level-txt').innerText = Math.floor(p.position.z/30)+1;
                                }
                            }
                            
                            // Sticky Moving Platforms
                            if (p.userData.move && p.userData.move.type === 'slide') {
                                const m = p.userData.move;
                                const moveDelta = (Math.sin(time * m.speed) - Math.sin((time-delta) * m.speed)) * m.range;
                                playerGroup.position.x += moveDelta;
                            }
                        }
                    }
                });

                if (playerGroup.position.y < -15) die();

                // Animation
                if (dir.lengthSq() > 0.1) {
                    playerGroup.rotation.y = Math.atan2(dir.x, dir.z); // Face movement
                    lLeg.rotation.x = Math.sin(time * 15) * 0.8;
                    rLeg.rotation.x = Math.sin(time * 15 + Math.PI) * 0.8;
                } else {
                    lLeg.rotation.x = 0; rLeg.rotation.x = 0;
                }

                // Camera
                const idealOff = new THREE.Vector3(0, 4, 8);
                idealOff.applyQuaternion(playerGroup.quaternion);
                // Simple follow
                camera.position.lerp(playerGroup.position.clone().add(new THREE.Vector3(0, 4, 8)), 0.1);
                camera.lookAt(playerGroup.position);
            }

            renderer.render(scene, camera);
        }
        animate();

        window.onresize = () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>
